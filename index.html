<!doctype html>
<html>
  <script type="text/javascript">
    (function () {
    	'use strict';

    	// generated during release, do not modify

    	const PUBLIC_VERSION = '5';

    	if (typeof window !== 'undefined')
    		// @ts-ignore
    		(window.__svelte ||= { v: new Set() }).v.add(PUBLIC_VERSION);

    	const EACH_ITEM_REACTIVE = 1;
    	const EACH_INDEX_REACTIVE = 1 << 1;
    	const EACH_ITEM_IMMUTABLE = 1 << 4;

    	const TEMPLATE_FRAGMENT = 1;
    	const TEMPLATE_USE_IMPORT_NODE = 1 << 1;

    	const HYDRATION_START = '[';
    	/** used to indicate that an `{:else}...` block was rendered */
    	const HYDRATION_START_ELSE = '[!';
    	const HYDRATION_END = ']';
    	const HYDRATION_ERROR = {};

    	const UNINITIALIZED = Symbol();

    	/**
    	 * Subset of delegated events which should be passive by default.
    	 * These two are already passive via browser defaults on window, document and body.
    	 * But since
    	 * - we're delegating them
    	 * - they happen often
    	 * - they apply to mobile which is generally less performant
    	 * we're marking them as passive by default for other elements, too.
    	 */
    	const PASSIVE_EVENTS = ['touchstart', 'touchmove'];

    	/**
    	 * Returns `true` if `name` is a passive event
    	 * @param {string} name
    	 */
    	function is_passive_event(name) {
    		return PASSIVE_EVENTS.includes(name);
    	}

    	var DEV = false;

    	// Store the references to globals in case someone tries to monkey patch these, causing the below
    	// to de-opt (this occurs often when using popular extensions).
    	var is_array = Array.isArray;
    	var array_from = Array.from;
    	var object_keys = Object.keys;
    	var define_property = Object.defineProperty;
    	var get_descriptor = Object.getOwnPropertyDescriptor;
    	var object_prototype = Object.prototype;
    	var array_prototype = Array.prototype;
    	var get_prototype_of = Object.getPrototypeOf;

    	/** @param {Array<() => void>} arr */
    	function run_all(arr) {
    		for (var i = 0; i < arr.length; i++) {
    			arr[i]();
    		}
    	}

    	const DERIVED = 1 << 1;
    	const EFFECT = 1 << 2;
    	const RENDER_EFFECT = 1 << 3;
    	const BLOCK_EFFECT = 1 << 4;
    	const BRANCH_EFFECT = 1 << 5;
    	const ROOT_EFFECT = 1 << 6;
    	const BOUNDARY_EFFECT = 1 << 7;
    	const UNOWNED = 1 << 8;
    	const DISCONNECTED = 1 << 9;
    	const CLEAN = 1 << 10;
    	const DIRTY = 1 << 11;
    	const MAYBE_DIRTY = 1 << 12;
    	const INERT = 1 << 13;
    	const DESTROYED = 1 << 14;
    	const EFFECT_RAN = 1 << 15;
    	/** 'Transparent' effects do not create a transition boundary */
    	const EFFECT_TRANSPARENT = 1 << 16;
    	const HEAD_EFFECT = 1 << 19;
    	const EFFECT_HAS_DERIVED = 1 << 20;

    	const STATE_SYMBOL = Symbol('$state');
    	const LEGACY_PROPS = Symbol('legacy props');

    	/** @import { Equals } from '#client' */
    	/** @type {Equals} */
    	function equals(value) {
    		return value === this.v;
    	}

    	/**
    	 * @param {unknown} a
    	 * @param {unknown} b
    	 * @returns {boolean}
    	 */
    	function safe_not_equal(a, b) {
    		return a != a
    			? b == b
    			: a !== b || (a !== null && typeof a === 'object') || typeof a === 'function';
    	}

    	/** @type {Equals} */
    	function safe_equals(value) {
    		return !safe_not_equal(value, this.v);
    	}

    	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


    	/**
    	 * Maximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops
    	 * @returns {never}
    	 */
    	function effect_update_depth_exceeded() {
    		{
    			throw new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);
    		}
    	}

    	/**
    	 * Failed to hydrate the application
    	 * @returns {never}
    	 */
    	function hydration_failed() {
    		{
    			throw new Error(`https://svelte.dev/e/hydration_failed`);
    		}
    	}

    	/**
    	 * Property descriptors defined on `$state` objects must contain `value` and always be `enumerable`, `configurable` and `writable`.
    	 * @returns {never}
    	 */
    	function state_descriptors_fixed() {
    		{
    			throw new Error(`https://svelte.dev/e/state_descriptors_fixed`);
    		}
    	}

    	/**
    	 * Cannot set prototype of `$state` object
    	 * @returns {never}
    	 */
    	function state_prototype_fixed() {
    		{
    			throw new Error(`https://svelte.dev/e/state_prototype_fixed`);
    		}
    	}

    	/**
    	 * Reading state that was created inside the same derived is forbidden. Consider using `untrack` to read locally created state
    	 * @returns {never}
    	 */
    	function state_unsafe_local_read() {
    		{
    			throw new Error(`https://svelte.dev/e/state_unsafe_local_read`);
    		}
    	}

    	/**
    	 * Updating state inside a derived or a template expression is forbidden. If the value should not be reactive, declare it without `$state`
    	 * @returns {never}
    	 */
    	function state_unsafe_mutation() {
    		{
    			throw new Error(`https://svelte.dev/e/state_unsafe_mutation`);
    		}
    	}

    	let legacy_mode_flag = false;

    	/** @import { Derived, Effect, Reaction, Source, Value } from '#client' */

    	/**
    	 * @template V
    	 * @param {V} v
    	 * @param {Error | null} [stack]
    	 * @returns {Source<V>}
    	 */
    	function source(v, stack) {
    		/** @type {Value} */
    		var signal = {
    			f: 0, // TODO ideally we could skip this altogether, but it causes type errors
    			v,
    			reactions: null,
    			equals,
    			version: 0
    		};

    		return signal;
    	}

    	/**
    	 * @template V
    	 * @param {V} v
    	 */
    	function state(v) {
    		return push_derived_source(source(v));
    	}

    	/**
    	 * @template V
    	 * @param {V} initial_value
    	 * @param {boolean} [immutable]
    	 * @returns {Source<V>}
    	 */
    	/*#__NO_SIDE_EFFECTS__*/
    	function mutable_source(initial_value, immutable = false) {
    		const s = source(initial_value);
    		if (!immutable) {
    			s.equals = safe_equals;
    		}

    		return s;
    	}

    	/**
    	 * @template V
    	 * @param {Source<V>} source
    	 */
    	/*#__NO_SIDE_EFFECTS__*/
    	function push_derived_source(source) {
    		if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {
    			if (derived_sources === null) {
    				set_derived_sources([source]);
    			} else {
    				derived_sources.push(source);
    			}
    		}

    		return source;
    	}

    	/**
    	 * @template V
    	 * @param {Source<V>} source
    	 * @param {V} value
    	 * @returns {V}
    	 */
    	function set(source, value) {
    		if (
    			active_reaction !== null &&
    			is_runes() &&
    			(active_reaction.f & (DERIVED | BLOCK_EFFECT)) !== 0 &&
    			// If the source was created locally within the current derived, then
    			// we allow the mutation.
    			(derived_sources === null || !derived_sources.includes(source))
    		) {
    			state_unsafe_mutation();
    		}

    		return internal_set(source, value);
    	}

    	/**
    	 * @template V
    	 * @param {Source<V>} source
    	 * @param {V} value
    	 * @returns {V}
    	 */
    	function internal_set(source, value) {
    		if (!source.equals(value)) {
    			source.v = value;
    			source.version = increment_version();

    			mark_reactions(source, DIRTY);

    			// If the current signal is running for the first time, it won't have any
    			// reactions as we only allocate and assign the reactions after the signal
    			// has fully executed. So in the case of ensuring it registers the reaction
    			// properly for itself, we need to ensure the current effect actually gets
    			// scheduled. i.e: `$effect(() => x++)`
    			if (
    				active_effect !== null &&
    				(active_effect.f & CLEAN) !== 0 &&
    				(active_effect.f & BRANCH_EFFECT) === 0
    			) {
    				if (new_deps !== null && new_deps.includes(source)) {
    					set_signal_status(active_effect, DIRTY);
    					schedule_effect(active_effect);
    				} else {
    					if (untracked_writes === null) {
    						set_untracked_writes([source]);
    					} else {
    						untracked_writes.push(source);
    					}
    				}
    			}
    		}

    		return value;
    	}

    	/**
    	 * @param {Value} signal
    	 * @param {number} status should be DIRTY or MAYBE_DIRTY
    	 * @returns {void}
    	 */
    	function mark_reactions(signal, status) {
    		var reactions = signal.reactions;
    		if (reactions === null) return;
    		var length = reactions.length;

    		for (var i = 0; i < length; i++) {
    			var reaction = reactions[i];
    			var flags = reaction.f;

    			// Skip any effects that are already dirty
    			if ((flags & DIRTY) !== 0) continue;

    			set_signal_status(reaction, status);

    			// If the signal a) was previously clean or b) is an unowned derived, then mark it
    			if ((flags & (CLEAN | UNOWNED)) !== 0) {
    				if ((flags & DERIVED) !== 0) {
    					mark_reactions(/** @type {Derived} */ (reaction), MAYBE_DIRTY);
    				} else {
    					schedule_effect(/** @type {Effect} */ (reaction));
    				}
    			}
    		}
    	}

    	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


    	/**
    	 * Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near %location%
    	 * @param {string | undefined | null} [location]
    	 */
    	function hydration_mismatch(location) {
    		{
    			console.warn(`https://svelte.dev/e/hydration_mismatch`);
    		}
    	}

    	/** @import { TemplateNode } from '#client' */


    	/**
    	 * Use this variable to guard everything related to hydration code so it can be treeshaken out
    	 * if the user doesn't use the `hydrate` method and these code paths are therefore not needed.
    	 */
    	let hydrating = false;

    	/** @param {boolean} value */
    	function set_hydrating(value) {
    		hydrating = value;
    	}

    	/**
    	 * The node that is currently being hydrated. This starts out as the first node inside the opening
    	 * <!--[--> comment, and updates each time a component calls `$.child(...)` or `$.sibling(...)`.
    	 * When entering a block (e.g. `{#if ...}`), `hydrate_node` is the block opening comment; by the
    	 * time we leave the block it is the closing comment, which serves as the block's anchor.
    	 * @type {TemplateNode}
    	 */
    	let hydrate_node;

    	/** @param {TemplateNode} node */
    	function set_hydrate_node(node) {
    		if (node === null) {
    			hydration_mismatch();
    			throw HYDRATION_ERROR;
    		}

    		return (hydrate_node = node);
    	}

    	function hydrate_next() {
    		return set_hydrate_node(/** @type {TemplateNode} */ (get_next_sibling(hydrate_node)));
    	}

    	/** @param {TemplateNode} node */
    	function reset(node) {
    		if (!hydrating) return;

    		// If the node has remaining siblings, something has gone wrong
    		if (get_next_sibling(hydrate_node) !== null) {
    			hydration_mismatch();
    			throw HYDRATION_ERROR;
    		}

    		hydrate_node = node;
    	}

    	/**
    	 * Removes all nodes starting at `hydrate_node` up until the next hydration end comment
    	 */
    	function remove_nodes() {
    		var depth = 0;
    		var node = hydrate_node;

    		while (true) {
    			if (node.nodeType === 8) {
    				var data = /** @type {Comment} */ (node).data;

    				if (data === HYDRATION_END) {
    					if (depth === 0) return node;
    					depth -= 1;
    				} else if (data === HYDRATION_START || data === HYDRATION_START_ELSE) {
    					depth += 1;
    				}
    			}

    			var next = /** @type {TemplateNode} */ (get_next_sibling(node));
    			node.remove();
    			node = next;
    		}
    	}

    	/** @import { ProxyMetadata, ProxyStateObject, Source } from '#client' */

    	/**
    	 * @template T
    	 * @param {T} value
    	 * @param {ProxyMetadata | null} [parent]
    	 * @param {Source<T>} [prev] dev mode only
    	 * @returns {T}
    	 */
    	function proxy(value, parent = null, prev) {
    		// if non-proxyable, or is already a proxy, return `value`
    		if (typeof value !== 'object' || value === null || STATE_SYMBOL in value) {
    			return value;
    		}

    		const prototype = get_prototype_of(value);

    		if (prototype !== object_prototype && prototype !== array_prototype) {
    			return value;
    		}

    		/** @type {Map<any, Source<any>>} */
    		var sources = new Map();
    		var is_proxied_array = is_array(value);
    		var version = source(0);

    		if (is_proxied_array) {
    			// We need to create the length source eagerly to ensure that
    			// mutations to the array are properly synced with our proxy
    			sources.set('length', source(/** @type {any[]} */ (value).length));
    		}

    		/** @type {ProxyMetadata} */
    		var metadata;

    		return new Proxy(/** @type {any} */ (value), {
    			defineProperty(_, prop, descriptor) {
    				if (
    					!('value' in descriptor) ||
    					descriptor.configurable === false ||
    					descriptor.enumerable === false ||
    					descriptor.writable === false
    				) {
    					// we disallow non-basic descriptors, because unless they are applied to the
    					// target object — which we avoid, so that state can be forked — we will run
    					// afoul of the various invariants
    					// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/getOwnPropertyDescriptor#invariants
    					state_descriptors_fixed();
    				}

    				var s = sources.get(prop);

    				if (s === undefined) {
    					s = source(descriptor.value);
    					sources.set(prop, s);
    				} else {
    					set(s, proxy(descriptor.value, metadata));
    				}

    				return true;
    			},

    			deleteProperty(target, prop) {
    				var s = sources.get(prop);

    				if (s === undefined) {
    					if (prop in target) {
    						sources.set(prop, source(UNINITIALIZED));
    					}
    				} else {
    					// When working with arrays, we need to also ensure we update the length when removing
    					// an indexed property
    					if (is_proxied_array && typeof prop === 'string') {
    						var ls = /** @type {Source<number>} */ (sources.get('length'));
    						var n = Number(prop);

    						if (Number.isInteger(n) && n < ls.v) {
    							set(ls, n);
    						}
    					}
    					set(s, UNINITIALIZED);
    					update_version(version);
    				}

    				return true;
    			},

    			get(target, prop, receiver) {

    				if (prop === STATE_SYMBOL) {
    					return value;
    				}

    				var s = sources.get(prop);
    				var exists = prop in target;

    				// create a source, but only if it's an own property and not a prototype property
    				if (s === undefined && (!exists || get_descriptor(target, prop)?.writable)) {
    					s = source(proxy(exists ? target[prop] : UNINITIALIZED, metadata));
    					sources.set(prop, s);
    				}

    				if (s !== undefined) {
    					var v = get(s);

    					return v === UNINITIALIZED ? undefined : v;
    				}

    				return Reflect.get(target, prop, receiver);
    			},

    			getOwnPropertyDescriptor(target, prop) {
    				var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);

    				if (descriptor && 'value' in descriptor) {
    					var s = sources.get(prop);
    					if (s) descriptor.value = get(s);
    				} else if (descriptor === undefined) {
    					var source = sources.get(prop);
    					var value = source?.v;

    					if (source !== undefined && value !== UNINITIALIZED) {
    						return {
    							enumerable: true,
    							configurable: true,
    							value,
    							writable: true
    						};
    					}
    				}

    				return descriptor;
    			},

    			has(target, prop) {

    				if (prop === STATE_SYMBOL) {
    					return true;
    				}

    				var s = sources.get(prop);
    				var has = (s !== undefined && s.v !== UNINITIALIZED) || Reflect.has(target, prop);

    				if (
    					s !== undefined ||
    					(active_effect !== null && (!has || get_descriptor(target, prop)?.writable))
    				) {
    					if (s === undefined) {
    						s = source(has ? proxy(target[prop], metadata) : UNINITIALIZED);
    						sources.set(prop, s);
    					}

    					var value = get(s);
    					if (value === UNINITIALIZED) {
    						return false;
    					}
    				}

    				return has;
    			},

    			set(target, prop, value, receiver) {
    				var s = sources.get(prop);
    				var has = prop in target;

    				// variable.length = value -> clear all signals with index >= value
    				if (is_proxied_array && prop === 'length') {
    					for (var i = value; i < /** @type {Source<number>} */ (s).v; i += 1) {
    						var other_s = sources.get(i + '');
    						if (other_s !== undefined) {
    							set(other_s, UNINITIALIZED);
    						} else if (i in target) {
    							// If the item exists in the original, we need to create a uninitialized source,
    							// else a later read of the property would result in a source being created with
    							// the value of the original item at that index.
    							other_s = source(UNINITIALIZED);
    							sources.set(i + '', other_s);
    						}
    					}
    				}

    				// If we haven't yet created a source for this property, we need to ensure
    				// we do so otherwise if we read it later, then the write won't be tracked and
    				// the heuristics of effects will be different vs if we had read the proxied
    				// object property before writing to that property.
    				if (s === undefined) {
    					if (!has || get_descriptor(target, prop)?.writable) {
    						s = source(undefined);
    						set(s, proxy(value, metadata));
    						sources.set(prop, s);
    					}
    				} else {
    					has = s.v !== UNINITIALIZED;
    					set(s, proxy(value, metadata));
    				}

    				var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);

    				// Set the new value before updating any signals so that any listeners get the new value
    				if (descriptor?.set) {
    					descriptor.set.call(receiver, value);
    				}

    				if (!has) {
    					// If we have mutated an array directly, we might need to
    					// signal that length has also changed. Do it before updating metadata
    					// to ensure that iterating over the array as a result of a metadata update
    					// will not cause the length to be out of sync.
    					if (is_proxied_array && typeof prop === 'string') {
    						var ls = /** @type {Source<number>} */ (sources.get('length'));
    						var n = Number(prop);

    						if (Number.isInteger(n) && n >= ls.v) {
    							set(ls, n + 1);
    						}
    					}

    					update_version(version);
    				}

    				return true;
    			},

    			ownKeys(target) {
    				get(version);

    				var own_keys = Reflect.ownKeys(target).filter((key) => {
    					var source = sources.get(key);
    					return source === undefined || source.v !== UNINITIALIZED;
    				});

    				for (var [key, source] of sources) {
    					if (source.v !== UNINITIALIZED && !(key in target)) {
    						own_keys.push(key);
    					}
    				}

    				return own_keys;
    			},

    			setPrototypeOf() {
    				state_prototype_fixed();
    			}
    		});
    	}

    	/**
    	 * @param {Source<number>} signal
    	 * @param {1 | -1} [d]
    	 */
    	function update_version(signal, d = 1) {
    		set(signal, signal.v + d);
    	}

    	/** @import { TemplateNode } from '#client' */

    	// export these for reference in the compiled code, making global name deduplication unnecessary
    	/** @type {Window} */
    	var $window;

    	/** @type {() => Node | null} */
    	var first_child_getter;
    	/** @type {() => Node | null} */
    	var next_sibling_getter;

    	/**
    	 * Initialize these lazily to avoid issues when using the runtime in a server context
    	 * where these globals are not available while avoiding a separate server entry point
    	 */
    	function init_operations() {
    		if ($window !== undefined) {
    			return;
    		}

    		$window = window;

    		var element_prototype = Element.prototype;
    		var node_prototype = Node.prototype;

    		// @ts-ignore
    		first_child_getter = get_descriptor(node_prototype, 'firstChild').get;
    		// @ts-ignore
    		next_sibling_getter = get_descriptor(node_prototype, 'nextSibling').get;

    		// the following assignments improve perf of lookups on DOM nodes
    		// @ts-expect-error
    		element_prototype.__click = undefined;
    		// @ts-expect-error
    		element_prototype.__className = '';
    		// @ts-expect-error
    		element_prototype.__attributes = null;
    		// @ts-expect-error
    		element_prototype.__styles = null;
    		// @ts-expect-error
    		element_prototype.__e = undefined;

    		// @ts-expect-error
    		Text.prototype.__t = undefined;
    	}

    	/**
    	 * @param {string} value
    	 * @returns {Text}
    	 */
    	function create_text(value = '') {
    		return document.createTextNode(value);
    	}

    	/**
    	 * @template {Node} N
    	 * @param {N} node
    	 * @returns {Node | null}
    	 */
    	/*@__NO_SIDE_EFFECTS__*/
    	function get_first_child(node) {
    		return first_child_getter.call(node);
    	}

    	/**
    	 * @template {Node} N
    	 * @param {N} node
    	 * @returns {Node | null}
    	 */
    	/*@__NO_SIDE_EFFECTS__*/
    	function get_next_sibling(node) {
    		return next_sibling_getter.call(node);
    	}

    	/**
    	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
    	 * @template {Node} N
    	 * @param {N} node
    	 * @param {boolean} is_text
    	 * @returns {Node | null}
    	 */
    	function child(node, is_text) {
    		if (!hydrating) {
    			return get_first_child(node);
    		}

    		var child = /** @type {TemplateNode} */ (get_first_child(hydrate_node));

    		// Child can be null if we have an element with a single child, like `<p>{text}</p>`, where `text` is empty
    		if (child === null) {
    			child = hydrate_node.appendChild(create_text());
    		} else if (is_text && child.nodeType !== 3) {
    			var text = create_text();
    			child?.before(text);
    			set_hydrate_node(text);
    			return text;
    		}

    		set_hydrate_node(child);
    		return child;
    	}

    	/**
    	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
    	 * @param {DocumentFragment | TemplateNode[]} fragment
    	 * @param {boolean} is_text
    	 * @returns {Node | null}
    	 */
    	function first_child(fragment, is_text) {
    		if (!hydrating) {
    			// when not hydrating, `fragment` is a `DocumentFragment` (the result of calling `open_frag`)
    			var first = /** @type {DocumentFragment} */ (get_first_child(/** @type {Node} */ (fragment)));

    			// TODO prevent user comments with the empty string when preserveComments is true
    			if (first instanceof Comment && first.data === '') return get_next_sibling(first);

    			return first;
    		}

    		return hydrate_node;
    	}

    	/**
    	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
    	 * @param {TemplateNode} node
    	 * @param {number} count
    	 * @param {boolean} is_text
    	 * @returns {Node | null}
    	 */
    	function sibling(node, count = 1, is_text = false) {
    		let next_sibling = hydrating ? hydrate_node : node;
    		var last_sibling;

    		while (count--) {
    			last_sibling = next_sibling;
    			next_sibling = /** @type {TemplateNode} */ (get_next_sibling(next_sibling));
    		}

    		if (!hydrating) {
    			return next_sibling;
    		}

    		var type = next_sibling?.nodeType;

    		// if a sibling {expression} is empty during SSR, there might be no
    		// text node to hydrate — we must therefore create one
    		if (is_text && type !== 3) {
    			var text = create_text();
    			// If the next sibling is `null` and we're handling text then it's because
    			// the SSR content was empty for the text, so we need to generate a new text
    			// node and insert it after the last sibling
    			if (next_sibling === null) {
    				last_sibling?.after(text);
    			} else {
    				next_sibling.before(text);
    			}
    			set_hydrate_node(text);
    			return text;
    		}

    		set_hydrate_node(next_sibling);
    		return /** @type {TemplateNode} */ (next_sibling);
    	}

    	/**
    	 * @template {Node} N
    	 * @param {N} node
    	 * @returns {void}
    	 */
    	function clear_text_content(node) {
    		node.textContent = '';
    	}

    	/** @import { Derived, Effect } from '#client' */

    	/**
    	 * @param {Derived} derived
    	 * @returns {void}
    	 */
    	function destroy_derived_children(derived) {
    		var children = derived.children;

    		if (children !== null) {
    			derived.children = null;

    			for (var i = 0; i < children.length; i += 1) {
    				var child = children[i];
    				if ((child.f & DERIVED) !== 0) {
    					destroy_derived(/** @type {Derived} */ (child));
    				} else {
    					destroy_effect(/** @type {Effect} */ (child));
    				}
    			}
    		}
    	}

    	/**
    	 * @param {Derived} derived
    	 * @returns {Effect | null}
    	 */
    	function get_derived_parent_effect(derived) {
    		var parent = derived.parent;
    		while (parent !== null) {
    			if ((parent.f & DERIVED) === 0) {
    				return /** @type {Effect} */ (parent);
    			}
    			parent = parent.parent;
    		}
    		return null;
    	}

    	/**
    	 * @template T
    	 * @param {Derived} derived
    	 * @returns {T}
    	 */
    	function execute_derived(derived) {
    		var value;
    		var prev_active_effect = active_effect;

    		set_active_effect(get_derived_parent_effect(derived));

    		{
    			try {
    				destroy_derived_children(derived);
    				value = update_reaction(derived);
    			} finally {
    				set_active_effect(prev_active_effect);
    			}
    		}

    		return value;
    	}

    	/**
    	 * @param {Derived} derived
    	 * @returns {void}
    	 */
    	function update_derived(derived) {
    		var value = execute_derived(derived);
    		var status =
    			(skip_reaction || (derived.f & UNOWNED) !== 0) && derived.deps !== null ? MAYBE_DIRTY : CLEAN;

    		set_signal_status(derived, status);

    		if (!derived.equals(value)) {
    			derived.v = value;
    			derived.version = increment_version();
    		}
    	}

    	/**
    	 * @param {Derived} derived
    	 * @returns {void}
    	 */
    	function destroy_derived(derived) {
    		destroy_derived_children(derived);
    		remove_reactions(derived, 0);
    		set_signal_status(derived, DESTROYED);

    		derived.v = derived.children = derived.deps = derived.ctx = derived.reactions = null;
    	}

    	/** @import { ComponentContext, ComponentContextLegacy, Derived, Effect, TemplateNode, TransitionManager } from '#client' */

    	/**
    	 * @param {Effect} effect
    	 * @param {Effect} parent_effect
    	 */
    	function push_effect(effect, parent_effect) {
    		var parent_last = parent_effect.last;
    		if (parent_last === null) {
    			parent_effect.last = parent_effect.first = effect;
    		} else {
    			parent_last.next = effect;
    			effect.prev = parent_last;
    			parent_effect.last = effect;
    		}
    	}

    	/**
    	 * @param {number} type
    	 * @param {null | (() => void | (() => void))} fn
    	 * @param {boolean} sync
    	 * @param {boolean} push
    	 * @returns {Effect}
    	 */
    	function create_effect(type, fn, sync, push = true) {
    		var is_root = (type & ROOT_EFFECT) !== 0;
    		var parent_effect = active_effect;

    		/** @type {Effect} */
    		var effect = {
    			ctx: component_context,
    			deps: null,
    			deriveds: null,
    			nodes_start: null,
    			nodes_end: null,
    			f: type | DIRTY,
    			first: null,
    			fn,
    			last: null,
    			next: null,
    			parent: is_root ? null : parent_effect,
    			prev: null,
    			teardown: null,
    			transitions: null,
    			version: 0
    		};

    		if (sync) {
    			var previously_flushing_effect = is_flushing_effect;

    			try {
    				set_is_flushing_effect(true);
    				update_effect(effect);
    				effect.f |= EFFECT_RAN;
    			} catch (e) {
    				destroy_effect(effect);
    				throw e;
    			} finally {
    				set_is_flushing_effect(previously_flushing_effect);
    			}
    		} else if (fn !== null) {
    			schedule_effect(effect);
    		}

    		// if an effect has no dependencies, no DOM and no teardown function,
    		// don't bother adding it to the effect tree
    		var inert =
    			sync &&
    			effect.deps === null &&
    			effect.first === null &&
    			effect.nodes_start === null &&
    			effect.teardown === null &&
    			(effect.f & EFFECT_HAS_DERIVED) === 0;

    		if (!inert && !is_root && push) {
    			if (parent_effect !== null) {
    				push_effect(effect, parent_effect);
    			}

    			// if we're in a derived, add the effect there too
    			if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {
    				var derived = /** @type {Derived} */ (active_reaction);
    				(derived.children ??= []).push(effect);
    			}
    		}

    		return effect;
    	}

    	/**
    	 * Internal representation of `$effect.root(...)`
    	 * @param {() => void | (() => void)} fn
    	 * @returns {() => void}
    	 */
    	function effect_root(fn) {
    		const effect = create_effect(ROOT_EFFECT, fn, true);

    		return () => {
    			destroy_effect(effect);
    		};
    	}

    	/**
    	 * An effect root whose children can transition out
    	 * @param {() => void} fn
    	 * @returns {(options?: { outro?: boolean }) => Promise<void>}
    	 */
    	function component_root(fn) {
    		const effect = create_effect(ROOT_EFFECT, fn, true);

    		return (options = {}) => {
    			return new Promise((fulfil) => {
    				if (options.outro) {
    					pause_effect(effect, () => {
    						destroy_effect(effect);
    						fulfil(undefined);
    					});
    				} else {
    					destroy_effect(effect);
    					fulfil(undefined);
    				}
    			});
    		};
    	}

    	/**
    	 * @param {() => void | (() => void)} fn
    	 * @returns {Effect}
    	 */
    	function effect(fn) {
    		return create_effect(EFFECT, fn, false);
    	}

    	/**
    	 * @param {() => void | (() => void)} fn
    	 * @returns {Effect}
    	 */
    	function render_effect(fn) {
    		return create_effect(RENDER_EFFECT, fn, true);
    	}

    	/**
    	 * @param {() => void | (() => void)} fn
    	 * @returns {Effect}
    	 */
    	function template_effect(fn) {
    		return block(fn);
    	}

    	/**
    	 * @param {(() => void)} fn
    	 * @param {number} flags
    	 */
    	function block(fn, flags = 0) {
    		return create_effect(RENDER_EFFECT | BLOCK_EFFECT | flags, fn, true);
    	}

    	/**
    	 * @param {(() => void)} fn
    	 * @param {boolean} [push]
    	 */
    	function branch(fn, push = true) {
    		return create_effect(RENDER_EFFECT | BRANCH_EFFECT, fn, true, push);
    	}

    	/**
    	 * @param {Effect} effect
    	 */
    	function execute_effect_teardown(effect) {
    		var teardown = effect.teardown;
    		if (teardown !== null) {
    			const previous_reaction = active_reaction;
    			set_active_reaction(null);
    			try {
    				teardown.call(null);
    			} finally {
    				set_active_reaction(previous_reaction);
    			}
    		}
    	}

    	/**
    	 * @param {Effect} signal
    	 * @returns {void}
    	 */
    	function destroy_effect_deriveds(signal) {
    		var deriveds = signal.deriveds;

    		if (deriveds !== null) {
    			signal.deriveds = null;

    			for (var i = 0; i < deriveds.length; i += 1) {
    				destroy_derived(deriveds[i]);
    			}
    		}
    	}

    	/**
    	 * @param {Effect} signal
    	 * @param {boolean} remove_dom
    	 * @returns {void}
    	 */
    	function destroy_effect_children(signal, remove_dom = false) {
    		var effect = signal.first;
    		signal.first = signal.last = null;

    		while (effect !== null) {
    			var next = effect.next;
    			destroy_effect(effect, remove_dom);
    			effect = next;
    		}
    	}

    	/**
    	 * @param {Effect} signal
    	 * @returns {void}
    	 */
    	function destroy_block_effect_children(signal) {
    		var effect = signal.first;

    		while (effect !== null) {
    			var next = effect.next;
    			if ((effect.f & BRANCH_EFFECT) === 0) {
    				destroy_effect(effect);
    			}
    			effect = next;
    		}
    	}

    	/**
    	 * @param {Effect} effect
    	 * @param {boolean} [remove_dom]
    	 * @returns {void}
    	 */
    	function destroy_effect(effect, remove_dom = true) {
    		var removed = false;

    		if ((remove_dom || (effect.f & HEAD_EFFECT) !== 0) && effect.nodes_start !== null) {
    			/** @type {TemplateNode | null} */
    			var node = effect.nodes_start;
    			var end = effect.nodes_end;

    			while (node !== null) {
    				/** @type {TemplateNode | null} */
    				var next = node === end ? null : /** @type {TemplateNode} */ (get_next_sibling(node));

    				node.remove();
    				node = next;
    			}

    			removed = true;
    		}

    		destroy_effect_children(effect, remove_dom && !removed);
    		destroy_effect_deriveds(effect);
    		remove_reactions(effect, 0);
    		set_signal_status(effect, DESTROYED);

    		var transitions = effect.transitions;

    		if (transitions !== null) {
    			for (const transition of transitions) {
    				transition.stop();
    			}
    		}

    		execute_effect_teardown(effect);

    		var parent = effect.parent;

    		// If the parent doesn't have any children, then skip this work altogether
    		if (parent !== null && parent.first !== null) {
    			unlink_effect(effect);
    		}

    		// `first` and `child` are nulled out in destroy_effect_children
    		// we don't null out `parent` so that error propagation can work correctly
    		effect.next =
    			effect.prev =
    			effect.teardown =
    			effect.ctx =
    			effect.deps =
    			effect.fn =
    			effect.nodes_start =
    			effect.nodes_end =
    				null;
    	}

    	/**
    	 * Detach an effect from the effect tree, freeing up memory and
    	 * reducing the amount of work that happens on subsequent traversals
    	 * @param {Effect} effect
    	 */
    	function unlink_effect(effect) {
    		var parent = effect.parent;
    		var prev = effect.prev;
    		var next = effect.next;

    		if (prev !== null) prev.next = next;
    		if (next !== null) next.prev = prev;

    		if (parent !== null) {
    			if (parent.first === effect) parent.first = next;
    			if (parent.last === effect) parent.last = prev;
    		}
    	}

    	/**
    	 * When a block effect is removed, we don't immediately destroy it or yank it
    	 * out of the DOM, because it might have transitions. Instead, we 'pause' it.
    	 * It stays around (in memory, and in the DOM) until outro transitions have
    	 * completed, and if the state change is reversed then we _resume_ it.
    	 * A paused effect does not update, and the DOM subtree becomes inert.
    	 * @param {Effect} effect
    	 * @param {() => void} [callback]
    	 */
    	function pause_effect(effect, callback) {
    		/** @type {TransitionManager[]} */
    		var transitions = [];

    		pause_children(effect, transitions, true);

    		run_out_transitions(transitions, () => {
    			destroy_effect(effect);
    			if (callback) callback();
    		});
    	}

    	/**
    	 * @param {TransitionManager[]} transitions
    	 * @param {() => void} fn
    	 */
    	function run_out_transitions(transitions, fn) {
    		var remaining = transitions.length;
    		if (remaining > 0) {
    			var check = () => --remaining || fn();
    			for (var transition of transitions) {
    				transition.out(check);
    			}
    		} else {
    			fn();
    		}
    	}

    	/**
    	 * @param {Effect} effect
    	 * @param {TransitionManager[]} transitions
    	 * @param {boolean} local
    	 */
    	function pause_children(effect, transitions, local) {
    		if ((effect.f & INERT) !== 0) return;
    		effect.f ^= INERT;

    		if (effect.transitions !== null) {
    			for (const transition of effect.transitions) {
    				if (transition.is_global || local) {
    					transitions.push(transition);
    				}
    			}
    		}

    		var child = effect.first;

    		while (child !== null) {
    			var sibling = child.next;
    			var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;
    			// TODO we don't need to call pause_children recursively with a linked list in place
    			// it's slightly more involved though as we have to account for `transparent` changing
    			// through the tree.
    			pause_children(child, transitions, transparent ? local : false);
    			child = sibling;
    		}
    	}

    	/**
    	 * The opposite of `pause_effect`. We call this if (for example)
    	 * `x` becomes falsy then truthy: `{#if x}...{/if}`
    	 * @param {Effect} effect
    	 */
    	function resume_effect(effect) {
    		resume_children(effect, true);
    	}

    	/**
    	 * @param {Effect} effect
    	 * @param {boolean} local
    	 */
    	function resume_children(effect, local) {
    		if ((effect.f & INERT) === 0) return;

    		// If a dependency of this effect changed while it was paused,
    		// apply the change now
    		if (check_dirtiness(effect)) {
    			update_effect(effect);
    		}

    		// Ensure we toggle the flag after possibly updating the effect so that
    		// each block logic can correctly operate on inert items
    		effect.f ^= INERT;

    		var child = effect.first;

    		while (child !== null) {
    			var sibling = child.next;
    			var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;
    			// TODO we don't need to call resume_children recursively with a linked list in place
    			// it's slightly more involved though as we have to account for `transparent` changing
    			// through the tree.
    			resume_children(child, transparent ? local : false);
    			child = sibling;
    		}

    		if (effect.transitions !== null) {
    			for (const transition of effect.transitions) {
    				if (transition.is_global || local) {
    					transition.in();
    				}
    			}
    		}
    	}

    	let is_micro_task_queued$1 = false;

    	/** @type {Array<() => void>} */
    	let current_queued_micro_tasks = [];

    	function process_micro_tasks() {
    		is_micro_task_queued$1 = false;
    		const tasks = current_queued_micro_tasks.slice();
    		current_queued_micro_tasks = [];
    		run_all(tasks);
    	}

    	/**
    	 * @param {() => void} fn
    	 */
    	function queue_micro_task(fn) {
    		if (!is_micro_task_queued$1) {
    			is_micro_task_queued$1 = true;
    			queueMicrotask(process_micro_tasks);
    		}
    		current_queued_micro_tasks.push(fn);
    	}

    	/**
    	 * Synchronously run any queued tasks.
    	 */
    	function flush_tasks() {
    		if (is_micro_task_queued$1) {
    			process_micro_tasks();
    		}
    	}

    	/** @import { ComponentContext, Derived, Effect, Reaction, Signal, Source, Value } from '#client' */

    	const FLUSH_MICROTASK = 0;
    	const FLUSH_SYNC = 1;
    	let is_throwing_error = false;

    	// Used for controlling the flush of effects.
    	let scheduler_mode = FLUSH_MICROTASK;
    	// Used for handling scheduling
    	let is_micro_task_queued = false;

    	/** @type {Effect | null} */
    	let last_scheduled_effect = null;

    	let is_flushing_effect = false;

    	/** @param {boolean} value */
    	function set_is_flushing_effect(value) {
    		is_flushing_effect = value;
    	}

    	// Handle effect queues

    	/** @type {Effect[]} */
    	let queued_root_effects = [];

    	let flush_count = 0;
    	/** @type {Effect[]} Stack of effects, dev only */
    	let dev_effect_stack = [];
    	// Handle signal reactivity tree dependencies and reactions

    	/** @type {null | Reaction} */
    	let active_reaction = null;

    	/** @param {null | Reaction} reaction */
    	function set_active_reaction(reaction) {
    		active_reaction = reaction;
    	}

    	/** @type {null | Effect} */
    	let active_effect = null;

    	/** @param {null | Effect} effect */
    	function set_active_effect(effect) {
    		active_effect = effect;
    	}

    	/**
    	 * When sources are created within a derived, we record them so that we can safely allow
    	 * local mutations to these sources without the side-effect error being invoked unnecessarily.
    	 * @type {null | Source[]}
    	 */
    	let derived_sources = null;

    	/**
    	 * @param {Source[] | null} sources
    	 */
    	function set_derived_sources(sources) {
    		derived_sources = sources;
    	}

    	/**
    	 * The dependencies of the reaction that is currently being executed. In many cases,
    	 * the dependencies are unchanged between runs, and so this will be `null` unless
    	 * and until a new dependency is accessed — we track this via `skipped_deps`
    	 * @type {null | Value[]}
    	 */
    	let new_deps = null;

    	let skipped_deps = 0;

    	/**
    	 * Tracks writes that the effect it's executed in doesn't listen to yet,
    	 * so that the dependency can be added to the effect later on if it then reads it
    	 * @type {null | Source[]}
    	 */
    	let untracked_writes = null;

    	/** @param {null | Source[]} value */
    	function set_untracked_writes(value) {
    		untracked_writes = value;
    	}

    	/** @type {number} Used by sources and deriveds for handling updates to unowned deriveds it starts from 1 to differentiate between a created effect and a run one for tracing */
    	let current_version = 1;

    	// If we are working with a get() chain that has no active container,
    	// to prevent memory leaks, we skip adding the reaction.
    	let skip_reaction = false;

    	// Handling runtime component context
    	/** @type {ComponentContext | null} */
    	let component_context = null;

    	function increment_version() {
    		return ++current_version;
    	}

    	/** @returns {boolean} */
    	function is_runes() {
    		return !legacy_mode_flag;
    	}

    	/**
    	 * Determines whether a derived or effect is dirty.
    	 * If it is MAYBE_DIRTY, will set the status to CLEAN
    	 * @param {Reaction} reaction
    	 * @returns {boolean}
    	 */
    	function check_dirtiness(reaction) {
    		var flags = reaction.f;

    		if ((flags & DIRTY) !== 0) {
    			return true;
    		}

    		if ((flags & MAYBE_DIRTY) !== 0) {
    			var dependencies = reaction.deps;
    			var is_unowned = (flags & UNOWNED) !== 0;

    			if (dependencies !== null) {
    				var i;
    				var dependency;
    				var is_disconnected = (flags & DISCONNECTED) !== 0;
    				var is_unowned_connected = is_unowned && active_effect !== null && !skip_reaction;
    				var length = dependencies.length;

    				// If we are working with a disconnected or an unowned signal that is now connected (due to an active effect)
    				// then we need to re-connect the reaction to the dependency
    				if (is_disconnected || is_unowned_connected) {
    					for (i = 0; i < length; i++) {
    						dependency = dependencies[i];

    						if (!dependency?.reactions?.includes(reaction)) {
    							(dependency.reactions ??= []).push(reaction);
    						}
    					}

    					if (is_disconnected) {
    						reaction.f ^= DISCONNECTED;
    					}
    				}

    				for (i = 0; i < length; i++) {
    					dependency = dependencies[i];

    					if (check_dirtiness(/** @type {Derived} */ (dependency))) {
    						update_derived(/** @type {Derived} */ (dependency));
    					}

    					if (dependency.version > reaction.version) {
    						return true;
    					}
    				}
    			}

    			// Unowned signals should never be marked as clean unless they
    			// are used within an active_effect without skip_reaction
    			if (!is_unowned || (active_effect !== null && !skip_reaction)) {
    				set_signal_status(reaction, CLEAN);
    			}
    		}

    		return false;
    	}

    	/**
    	 * @param {unknown} error
    	 * @param {Effect} effect
    	 */
    	function propagate_error(error, effect) {
    		/** @type {Effect | null} */
    		var current = effect;

    		while (current !== null) {
    			if ((current.f & BOUNDARY_EFFECT) !== 0) {
    				try {
    					// @ts-expect-error
    					current.fn(error);
    					return;
    				} catch {
    					// Remove boundary flag from effect
    					current.f ^= BOUNDARY_EFFECT;
    				}
    			}

    			current = current.parent;
    		}

    		is_throwing_error = false;
    		throw error;
    	}

    	/**
    	 * @param {Effect} effect
    	 */
    	function should_rethrow_error(effect) {
    		return (
    			(effect.f & DESTROYED) === 0 &&
    			(effect.parent === null || (effect.parent.f & BOUNDARY_EFFECT) === 0)
    		);
    	}

    	/**
    	 * @param {unknown} error
    	 * @param {Effect} effect
    	 * @param {Effect | null} previous_effect
    	 * @param {ComponentContext | null} component_context
    	 */
    	function handle_error(error, effect, previous_effect, component_context) {
    		if (is_throwing_error) {
    			if (previous_effect === null) {
    				is_throwing_error = false;
    			}

    			if (should_rethrow_error(effect)) {
    				throw error;
    			}

    			return;
    		}

    		if (previous_effect !== null) {
    			is_throwing_error = true;
    		}

    		{
    			propagate_error(error, effect);
    			return;
    		}
    	}

    	/**
    	 * @template V
    	 * @param {Reaction} reaction
    	 * @returns {V}
    	 */
    	function update_reaction(reaction) {
    		var previous_deps = new_deps;
    		var previous_skipped_deps = skipped_deps;
    		var previous_untracked_writes = untracked_writes;
    		var previous_reaction = active_reaction;
    		var previous_skip_reaction = skip_reaction;
    		var prev_derived_sources = derived_sources;
    		var previous_component_context = component_context;
    		var flags = reaction.f;

    		new_deps = /** @type {null | Value[]} */ (null);
    		skipped_deps = 0;
    		untracked_writes = null;
    		active_reaction = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;
    		skip_reaction = !is_flushing_effect && (flags & UNOWNED) !== 0;
    		derived_sources = null;
    		component_context = reaction.ctx;

    		try {
    			var result = /** @type {Function} */ (0, reaction.fn)();
    			var deps = reaction.deps;

    			if (new_deps !== null) {
    				var i;

    				remove_reactions(reaction, skipped_deps);

    				if (deps !== null && skipped_deps > 0) {
    					deps.length = skipped_deps + new_deps.length;
    					for (i = 0; i < new_deps.length; i++) {
    						deps[skipped_deps + i] = new_deps[i];
    					}
    				} else {
    					reaction.deps = deps = new_deps;
    				}

    				if (!skip_reaction) {
    					for (i = skipped_deps; i < deps.length; i++) {
    						(deps[i].reactions ??= []).push(reaction);
    					}
    				}
    			} else if (deps !== null && skipped_deps < deps.length) {
    				remove_reactions(reaction, skipped_deps);
    				deps.length = skipped_deps;
    			}

    			return result;
    		} finally {
    			new_deps = previous_deps;
    			skipped_deps = previous_skipped_deps;
    			untracked_writes = previous_untracked_writes;
    			active_reaction = previous_reaction;
    			skip_reaction = previous_skip_reaction;
    			derived_sources = prev_derived_sources;
    			component_context = previous_component_context;
    		}
    	}

    	/**
    	 * @template V
    	 * @param {Reaction} signal
    	 * @param {Value<V>} dependency
    	 * @returns {void}
    	 */
    	function remove_reaction(signal, dependency) {
    		let reactions = dependency.reactions;
    		if (reactions !== null) {
    			var index = reactions.indexOf(signal);
    			if (index !== -1) {
    				var new_length = reactions.length - 1;
    				if (new_length === 0) {
    					reactions = dependency.reactions = null;
    				} else {
    					// Swap with last element and then remove.
    					reactions[index] = reactions[new_length];
    					reactions.pop();
    				}
    			}
    		}
    		// If the derived has no reactions, then we can disconnect it from the graph,
    		// allowing it to either reconnect in the future, or be GC'd by the VM.
    		if (
    			reactions === null &&
    			(dependency.f & DERIVED) !== 0 &&
    			// Destroying a child effect while updating a parent effect can cause a dependency to appear
    			// to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
    			// allows us to skip the expensive work of disconnecting and immediately reconnecting it
    			(new_deps === null || !new_deps.includes(dependency))
    		) {
    			set_signal_status(dependency, MAYBE_DIRTY);
    			// If we are working with a derived that is owned by an effect, then mark it as being
    			// disconnected.
    			if ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {
    				dependency.f ^= DISCONNECTED;
    			}
    			remove_reactions(/** @type {Derived} **/ (dependency), 0);
    		}
    	}

    	/**
    	 * @param {Reaction} signal
    	 * @param {number} start_index
    	 * @returns {void}
    	 */
    	function remove_reactions(signal, start_index) {
    		var dependencies = signal.deps;
    		if (dependencies === null) return;

    		for (var i = start_index; i < dependencies.length; i++) {
    			remove_reaction(signal, dependencies[i]);
    		}
    	}

    	/**
    	 * @param {Effect} effect
    	 * @returns {void}
    	 */
    	function update_effect(effect) {
    		var flags = effect.f;

    		if ((flags & DESTROYED) !== 0) {
    			return;
    		}

    		set_signal_status(effect, CLEAN);

    		var previous_effect = active_effect;
    		var previous_component_context = component_context;

    		active_effect = effect;

    		try {
    			if ((flags & BLOCK_EFFECT) !== 0) {
    				destroy_block_effect_children(effect);
    			} else {
    				destroy_effect_children(effect);
    			}
    			destroy_effect_deriveds(effect);

    			execute_effect_teardown(effect);
    			var teardown = update_reaction(effect);
    			effect.teardown = typeof teardown === 'function' ? teardown : null;
    			effect.version = current_version;

    			if (DEV) ;
    		} catch (error) {
    			handle_error(error, effect, previous_effect, previous_component_context || effect.ctx);
    		} finally {
    			active_effect = previous_effect;
    		}
    	}

    	function infinite_loop_guard() {
    		if (flush_count > 1000) {
    			flush_count = 0;
    			try {
    				effect_update_depth_exceeded();
    			} catch (error) {
    				// Try and handle the error so it can be caught at a boundary, that's
    				// if there's an effect available from when it was last scheduled
    				if (last_scheduled_effect !== null) {
    					{
    						handle_error(error, last_scheduled_effect, null);
    					}
    				} else {
    					throw error;
    				}
    			}
    		}
    		flush_count++;
    	}

    	/**
    	 * @param {Array<Effect>} root_effects
    	 * @returns {void}
    	 */
    	function flush_queued_root_effects(root_effects) {
    		var length = root_effects.length;
    		if (length === 0) {
    			return;
    		}
    		infinite_loop_guard();

    		var previously_flushing_effect = is_flushing_effect;
    		is_flushing_effect = true;

    		try {
    			for (var i = 0; i < length; i++) {
    				var effect = root_effects[i];

    				if ((effect.f & CLEAN) === 0) {
    					effect.f ^= CLEAN;
    				}

    				/** @type {Effect[]} */
    				var collected_effects = [];

    				process_effects(effect, collected_effects);
    				flush_queued_effects(collected_effects);
    			}
    		} finally {
    			is_flushing_effect = previously_flushing_effect;
    		}
    	}

    	/**
    	 * @param {Array<Effect>} effects
    	 * @returns {void}
    	 */
    	function flush_queued_effects(effects) {
    		var length = effects.length;
    		if (length === 0) return;

    		for (var i = 0; i < length; i++) {
    			var effect = effects[i];

    			if ((effect.f & (DESTROYED | INERT)) === 0) {
    				try {
    					if (check_dirtiness(effect)) {
    						update_effect(effect);

    						// Effects with no dependencies or teardown do not get added to the effect tree.
    						// Deferred effects (e.g. `$effect(...)`) _are_ added to the tree because we
    						// don't know if we need to keep them until they are executed. Doing the check
    						// here (rather than in `update_effect`) allows us to skip the work for
    						// immediate effects.
    						if (effect.deps === null && effect.first === null && effect.nodes_start === null) {
    							if (effect.teardown === null) {
    								// remove this effect from the graph
    								unlink_effect(effect);
    							} else {
    								// keep the effect in the graph, but free up some memory
    								effect.fn = null;
    							}
    						}
    					}
    				} catch (error) {
    					handle_error(error, effect, null, effect.ctx);
    				}
    			}
    		}
    	}

    	function process_deferred() {
    		is_micro_task_queued = false;
    		if (flush_count > 1001) {
    			return;
    		}
    		const previous_queued_root_effects = queued_root_effects;
    		queued_root_effects = [];
    		flush_queued_root_effects(previous_queued_root_effects);

    		if (!is_micro_task_queued) {
    			flush_count = 0;
    			last_scheduled_effect = null;
    		}
    	}

    	/**
    	 * @param {Effect} signal
    	 * @returns {void}
    	 */
    	function schedule_effect(signal) {
    		if (scheduler_mode === FLUSH_MICROTASK) {
    			if (!is_micro_task_queued) {
    				is_micro_task_queued = true;
    				queueMicrotask(process_deferred);
    			}
    		}

    		last_scheduled_effect = signal;

    		var effect = signal;

    		while (effect.parent !== null) {
    			effect = effect.parent;
    			var flags = effect.f;

    			if ((flags & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
    				if ((flags & CLEAN) === 0) return;
    				effect.f ^= CLEAN;
    			}
    		}

    		queued_root_effects.push(effect);
    	}

    	/**
    	 *
    	 * This function both runs render effects and collects user effects in topological order
    	 * from the starting effect passed in. Effects will be collected when they match the filtered
    	 * bitwise flag passed in only. The collected effects array will be populated with all the user
    	 * effects to be flushed.
    	 *
    	 * @param {Effect} effect
    	 * @param {Effect[]} collected_effects
    	 * @returns {void}
    	 */
    	function process_effects(effect, collected_effects) {
    		var current_effect = effect.first;
    		var effects = [];

    		main_loop: while (current_effect !== null) {
    			var flags = current_effect.f;
    			var is_branch = (flags & BRANCH_EFFECT) !== 0;
    			var is_skippable_branch = is_branch && (flags & CLEAN) !== 0;
    			var sibling = current_effect.next;

    			if (!is_skippable_branch && (flags & INERT) === 0) {
    				if ((flags & RENDER_EFFECT) !== 0) {
    					if (is_branch) {
    						current_effect.f ^= CLEAN;
    					} else {
    						try {
    							if (check_dirtiness(current_effect)) {
    								update_effect(current_effect);
    							}
    						} catch (error) {
    							handle_error(error, current_effect, null, current_effect.ctx);
    						}
    					}

    					var child = current_effect.first;

    					if (child !== null) {
    						current_effect = child;
    						continue;
    					}
    				} else if ((flags & EFFECT) !== 0) {
    					effects.push(current_effect);
    				}
    			}

    			if (sibling === null) {
    				let parent = current_effect.parent;

    				while (parent !== null) {
    					if (effect === parent) {
    						break main_loop;
    					}
    					var parent_sibling = parent.next;
    					if (parent_sibling !== null) {
    						current_effect = parent_sibling;
    						continue main_loop;
    					}
    					parent = parent.parent;
    				}
    			}

    			current_effect = sibling;
    		}

    		// We might be dealing with many effects here, far more than can be spread into
    		// an array push call (callstack overflow). So let's deal with each effect in a loop.
    		for (var i = 0; i < effects.length; i++) {
    			child = effects[i];
    			collected_effects.push(child);
    			process_effects(child, collected_effects);
    		}
    	}

    	/**
    	 * Internal version of `flushSync` with the option to not flush previous effects.
    	 * Returns the result of the passed function, if given.
    	 * @param {() => any} [fn]
    	 * @returns {any}
    	 */
    	function flush_sync(fn) {
    		var previous_scheduler_mode = scheduler_mode;
    		var previous_queued_root_effects = queued_root_effects;

    		try {
    			infinite_loop_guard();

    			/** @type {Effect[]} */
    			const root_effects = [];

    			scheduler_mode = FLUSH_SYNC;
    			queued_root_effects = root_effects;
    			is_micro_task_queued = false;

    			flush_queued_root_effects(previous_queued_root_effects);

    			var result = fn?.();

    			flush_tasks();
    			if (queued_root_effects.length > 0 || root_effects.length > 0) {
    				flush_sync();
    			}

    			flush_count = 0;
    			last_scheduled_effect = null;
    			if (DEV) ;

    			return result;
    		} finally {
    			scheduler_mode = previous_scheduler_mode;
    			queued_root_effects = previous_queued_root_effects;
    		}
    	}

    	/**
    	 * @template V
    	 * @param {Value<V>} signal
    	 * @returns {V}
    	 */
    	function get(signal) {
    		var flags = signal.f;
    		var is_derived = (flags & DERIVED) !== 0;

    		// If the derived is destroyed, just execute it again without retaining
    		// its memoisation properties as the derived is stale
    		if (is_derived && (flags & DESTROYED) !== 0) {
    			var value = execute_derived(/** @type {Derived} */ (signal));
    			// Ensure the derived remains destroyed
    			destroy_derived(/** @type {Derived} */ (signal));
    			return value;
    		}

    		// Register the dependency on the current reaction signal.
    		if (active_reaction !== null) {
    			if (derived_sources !== null && derived_sources.includes(signal)) {
    				state_unsafe_local_read();
    			}
    			var deps = active_reaction.deps;

    			// If the signal is accessing the same dependencies in the same
    			// order as it did last time, increment `skipped_deps`
    			// rather than updating `new_deps`, which creates GC cost
    			if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
    				skipped_deps++;
    			} else if (new_deps === null) {
    				new_deps = [signal];
    			} else {
    				new_deps.push(signal);
    			}

    			if (
    				untracked_writes !== null &&
    				active_effect !== null &&
    				(active_effect.f & CLEAN) !== 0 &&
    				(active_effect.f & BRANCH_EFFECT) === 0 &&
    				untracked_writes.includes(signal)
    			) {
    				set_signal_status(active_effect, DIRTY);
    				schedule_effect(active_effect);
    			}
    		} else if (is_derived && /** @type {Derived} */ (signal).deps === null) {
    			var derived = /** @type {Derived} */ (signal);
    			var parent = derived.parent;
    			var target = derived;

    			while (parent !== null) {
    				// Attach the derived to the nearest parent effect, if there are deriveds
    				// in between then we also need to attach them too
    				if ((parent.f & DERIVED) !== 0) {
    					var parent_derived = /** @type {Derived} */ (parent);

    					target = parent_derived;
    					parent = parent_derived.parent;
    				} else {
    					var parent_effect = /** @type {Effect} */ (parent);

    					if (!parent_effect.deriveds?.includes(target)) {
    						(parent_effect.deriveds ??= []).push(target);
    					}
    					break;
    				}
    			}
    		}

    		if (is_derived) {
    			derived = /** @type {Derived} */ (signal);

    			if (check_dirtiness(derived)) {
    				update_derived(derived);
    			}
    		}

    		return signal.v;
    	}

    	const STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);

    	/**
    	 * @param {Signal} signal
    	 * @param {number} status
    	 * @returns {void}
    	 */
    	function set_signal_status(signal, status) {
    		signal.f = (signal.f & STATUS_MASK) | status;
    	}

    	/**
    	 * @param {Record<string, unknown>} props
    	 * @param {any} runes
    	 * @param {Function} [fn]
    	 * @returns {void}
    	 */
    	function push(props, runes = false, fn) {
    		component_context = {
    			p: component_context,
    			c: null,
    			e: null,
    			m: false,
    			s: props,
    			x: null,
    			l: null
    		};
    	}

    	/**
    	 * @template {Record<string, any>} T
    	 * @param {T} [component]
    	 * @returns {T}
    	 */
    	function pop(component) {
    		const context_stack_item = component_context;
    		if (context_stack_item !== null) {
    			const component_effects = context_stack_item.e;
    			if (component_effects !== null) {
    				var previous_effect = active_effect;
    				var previous_reaction = active_reaction;
    				context_stack_item.e = null;
    				try {
    					for (var i = 0; i < component_effects.length; i++) {
    						var component_effect = component_effects[i];
    						set_active_effect(component_effect.effect);
    						set_active_reaction(component_effect.reaction);
    						effect(component_effect.fn);
    					}
    				} finally {
    					set_active_effect(previous_effect);
    					set_active_reaction(previous_reaction);
    				}
    			}
    			component_context = context_stack_item.p;
    			context_stack_item.m = true;
    		}
    		// Micro-optimization: Don't set .a above to the empty object
    		// so it can be garbage-collected when the return here is unused
    		return /** @type {T} */ ({});
    	}

    	/** @import { Location } from 'locate-character' */

    	/** @type {Set<string>} */
    	const all_registered_events = new Set();

    	/** @type {Set<(events: Array<string>) => void>} */
    	const root_event_handles = new Set();

    	/**
    	 * @param {Array<string>} events
    	 * @returns {void}
    	 */
    	function delegate(events) {
    		for (var i = 0; i < events.length; i++) {
    			all_registered_events.add(events[i]);
    		}

    		for (var fn of root_event_handles) {
    			fn(events);
    		}
    	}

    	/**
    	 * @this {EventTarget}
    	 * @param {Event} event
    	 * @returns {void}
    	 */
    	function handle_event_propagation(event) {
    		var handler_element = this;
    		var owner_document = /** @type {Node} */ (handler_element).ownerDocument;
    		var event_name = event.type;
    		var path = event.composedPath?.() || [];
    		var current_target = /** @type {null | Element} */ (path[0] || event.target);

    		// composedPath contains list of nodes the event has propagated through.
    		// We check __root to skip all nodes below it in case this is a
    		// parent of the __root node, which indicates that there's nested
    		// mounted apps. In this case we don't want to trigger events multiple times.
    		var path_idx = 0;

    		// @ts-expect-error is added below
    		var handled_at = event.__root;

    		if (handled_at) {
    			var at_idx = path.indexOf(handled_at);
    			if (
    				at_idx !== -1 &&
    				(handler_element === document || handler_element === /** @type {any} */ (window))
    			) {
    				// This is the fallback document listener or a window listener, but the event was already handled
    				// -> ignore, but set handle_at to document/window so that we're resetting the event
    				// chain in case someone manually dispatches the same event object again.
    				// @ts-expect-error
    				event.__root = handler_element;
    				return;
    			}

    			// We're deliberately not skipping if the index is higher, because
    			// someone could create an event programmatically and emit it multiple times,
    			// in which case we want to handle the whole propagation chain properly each time.
    			// (this will only be a false negative if the event is dispatched multiple times and
    			// the fallback document listener isn't reached in between, but that's super rare)
    			var handler_idx = path.indexOf(handler_element);
    			if (handler_idx === -1) {
    				// handle_idx can theoretically be -1 (happened in some JSDOM testing scenarios with an event listener on the window object)
    				// so guard against that, too, and assume that everything was handled at this point.
    				return;
    			}

    			if (at_idx <= handler_idx) {
    				path_idx = at_idx;
    			}
    		}

    		current_target = /** @type {Element} */ (path[path_idx] || event.target);
    		// there can only be one delegated event per element, and we either already handled the current target,
    		// or this is the very first target in the chain which has a non-delegated listener, in which case it's safe
    		// to handle a possible delegated event on it later (through the root delegation listener for example).
    		if (current_target === handler_element) return;

    		// Proxy currentTarget to correct target
    		define_property(event, 'currentTarget', {
    			configurable: true,
    			get() {
    				return current_target || owner_document;
    			}
    		});

    		// This started because of Chromium issue https://chromestatus.com/feature/5128696823545856,
    		// where removal or moving of of the DOM can cause sync `blur` events to fire, which can cause logic
    		// to run inside the current `active_reaction`, which isn't what we want at all. However, on reflection,
    		// it's probably best that all event handled by Svelte have this behaviour, as we don't really want
    		// an event handler to run in the context of another reaction or effect.
    		var previous_reaction = active_reaction;
    		var previous_effect = active_effect;
    		set_active_reaction(null);
    		set_active_effect(null);

    		try {
    			/**
    			 * @type {unknown}
    			 */
    			var throw_error;
    			/**
    			 * @type {unknown[]}
    			 */
    			var other_errors = [];

    			while (current_target !== null) {
    				/** @type {null | Element} */
    				var parent_element =
    					current_target.assignedSlot ||
    					current_target.parentNode ||
    					/** @type {any} */ (current_target).host ||
    					null;

    				try {
    					// @ts-expect-error
    					var delegated = current_target['__' + event_name];

    					if (delegated !== undefined && !(/** @type {any} */ (current_target).disabled)) {
    						if (is_array(delegated)) {
    							var [fn, ...data] = delegated;
    							fn.apply(current_target, [event, ...data]);
    						} else {
    							delegated.call(current_target, event);
    						}
    					}
    				} catch (error) {
    					if (throw_error) {
    						other_errors.push(error);
    					} else {
    						throw_error = error;
    					}
    				}
    				if (event.cancelBubble || parent_element === handler_element || parent_element === null) {
    					break;
    				}
    				current_target = parent_element;
    			}

    			if (throw_error) {
    				for (let error of other_errors) {
    					// Throw the rest of the errors, one-by-one on a microtask
    					queueMicrotask(() => {
    						throw error;
    					});
    				}
    				throw throw_error;
    			}
    		} finally {
    			// @ts-expect-error is used above
    			event.__root = handler_element;
    			// @ts-ignore remove proxy on currentTarget
    			delete event.currentTarget;
    			set_active_reaction(previous_reaction);
    			set_active_effect(previous_effect);
    		}
    	}

    	/** @param {string} html */
    	function create_fragment_from_html(html) {
    		var elem = document.createElement('template');
    		elem.innerHTML = html;
    		return elem.content;
    	}

    	/** @import { Effect, TemplateNode } from '#client' */

    	/**
    	 * @param {TemplateNode} start
    	 * @param {TemplateNode | null} end
    	 */
    	function assign_nodes(start, end) {
    		var effect = /** @type {Effect} */ (active_effect);
    		if (effect.nodes_start === null) {
    			effect.nodes_start = start;
    			effect.nodes_end = end;
    		}
    	}

    	/**
    	 * @param {string} content
    	 * @param {number} flags
    	 * @returns {() => Node | Node[]}
    	 */
    	/*#__NO_SIDE_EFFECTS__*/
    	function template(content, flags) {
    		var is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;
    		var use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;

    		/** @type {Node} */
    		var node;

    		/**
    		 * Whether or not the first item is a text/element node. If not, we need to
    		 * create an additional comment node to act as `effect.nodes.start`
    		 */
    		var has_start = !content.startsWith('<!>');

    		return () => {
    			if (hydrating) {
    				assign_nodes(hydrate_node, null);
    				return hydrate_node;
    			}

    			if (node === undefined) {
    				node = create_fragment_from_html(has_start ? content : '<!>' + content);
    				if (!is_fragment) node = /** @type {Node} */ (get_first_child(node));
    			}

    			var clone = /** @type {TemplateNode} */ (
    				use_import_node ? document.importNode(node, true) : node.cloneNode(true)
    			);

    			if (is_fragment) {
    				var start = /** @type {TemplateNode} */ (get_first_child(clone));
    				var end = /** @type {TemplateNode} */ (clone.lastChild);

    				assign_nodes(start, end);
    			} else {
    				assign_nodes(clone, clone);
    			}

    			return clone;
    		};
    	}

    	function comment() {
    		// we're not delegating to `template` here for performance reasons
    		if (hydrating) {
    			assign_nodes(hydrate_node, null);
    			return hydrate_node;
    		}

    		var frag = document.createDocumentFragment();
    		var start = document.createComment('');
    		var anchor = create_text();
    		frag.append(start, anchor);

    		assign_nodes(start, anchor);

    		return frag;
    	}

    	/**
    	 * Assign the created (or in hydration mode, traversed) dom elements to the current block
    	 * and insert the elements into the dom (in client mode).
    	 * @param {Text | Comment | Element} anchor
    	 * @param {DocumentFragment | Element} dom
    	 */
    	function append(anchor, dom) {
    		if (hydrating) {
    			/** @type {Effect} */ (active_effect).nodes_end = hydrate_node;
    			hydrate_next();
    			return;
    		}

    		if (anchor === null) {
    			// edge case — void `<svelte:element>` with content
    			return;
    		}

    		anchor.before(/** @type {Node} */ (dom));
    	}

    	/** @import { ComponentContext, Effect, TemplateNode } from '#client' */
    	/** @import { Component, ComponentType, SvelteComponent, MountOptions } from '../../index.js' */

    	/**
    	 * @param {Element} text
    	 * @param {string} value
    	 * @returns {void}
    	 */
    	function set_text(text, value) {
    		// For objects, we apply string coercion (which might make things like $state array references in the template reactive) before diffing
    		var str = value == null ? '' : typeof value === 'object' ? value + '' : value;
    		// @ts-expect-error
    		if (str !== (text.__t ??= text.nodeValue)) {
    			// @ts-expect-error
    			text.__t = str;
    			text.nodeValue = str == null ? '' : str + '';
    		}
    	}

    	/**
    	 * Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component.
    	 * Transitions will play during the initial render unless the `intro` option is set to `false`.
    	 *
    	 * @template {Record<string, any>} Props
    	 * @template {Record<string, any>} Exports
    	 * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component
    	 * @param {MountOptions<Props>} options
    	 * @returns {Exports}
    	 */
    	function mount(component, options) {
    		return _mount(component, options);
    	}

    	/**
    	 * Hydrates a component on the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component
    	 *
    	 * @template {Record<string, any>} Props
    	 * @template {Record<string, any>} Exports
    	 * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component
    	 * @param {{} extends Props ? {
    	 * 		target: Document | Element | ShadowRoot;
    	 * 		props?: Props;
    	 * 		events?: Record<string, (e: any) => any>;
    	 *  	context?: Map<any, any>;
    	 * 		intro?: boolean;
    	 * 		recover?: boolean;
    	 * 	} : {
    	 * 		target: Document | Element | ShadowRoot;
    	 * 		props: Props;
    	 * 		events?: Record<string, (e: any) => any>;
    	 *  	context?: Map<any, any>;
    	 * 		intro?: boolean;
    	 * 		recover?: boolean;
    	 * 	}} options
    	 * @returns {Exports}
    	 */
    	function hydrate(component, options) {
    		init_operations();
    		options.intro = options.intro ?? false;
    		const target = options.target;
    		const was_hydrating = hydrating;
    		const previous_hydrate_node = hydrate_node;

    		try {
    			var anchor = /** @type {TemplateNode} */ (get_first_child(target));
    			while (
    				anchor &&
    				(anchor.nodeType !== 8 || /** @type {Comment} */ (anchor).data !== HYDRATION_START)
    			) {
    				anchor = /** @type {TemplateNode} */ (get_next_sibling(anchor));
    			}

    			if (!anchor) {
    				throw HYDRATION_ERROR;
    			}

    			set_hydrating(true);
    			set_hydrate_node(/** @type {Comment} */ (anchor));
    			hydrate_next();

    			const instance = _mount(component, { ...options, anchor });

    			if (
    				hydrate_node === null ||
    				hydrate_node.nodeType !== 8 ||
    				/** @type {Comment} */ (hydrate_node).data !== HYDRATION_END
    			) {
    				hydration_mismatch();
    				throw HYDRATION_ERROR;
    			}

    			set_hydrating(false);

    			return /**  @type {Exports} */ (instance);
    		} catch (error) {
    			if (error === HYDRATION_ERROR) {
    				if (options.recover === false) {
    					hydration_failed();
    				}

    				// If an error occured above, the operations might not yet have been initialised.
    				init_operations();
    				clear_text_content(target);

    				set_hydrating(false);
    				return mount(component, options);
    			}

    			throw error;
    		} finally {
    			set_hydrating(was_hydrating);
    			set_hydrate_node(previous_hydrate_node);
    		}
    	}

    	/** @type {Map<string, number>} */
    	const document_listeners = new Map();

    	/**
    	 * @template {Record<string, any>} Exports
    	 * @param {ComponentType<SvelteComponent<any>> | Component<any>} Component
    	 * @param {MountOptions} options
    	 * @returns {Exports}
    	 */
    	function _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {
    		init_operations();

    		var registered_events = new Set();

    		/** @param {Array<string>} events */
    		var event_handle = (events) => {
    			for (var i = 0; i < events.length; i++) {
    				var event_name = events[i];

    				if (registered_events.has(event_name)) continue;
    				registered_events.add(event_name);

    				var passive = is_passive_event(event_name);

    				// Add the event listener to both the container and the document.
    				// The container listener ensures we catch events from within in case
    				// the outer content stops propagation of the event.
    				target.addEventListener(event_name, handle_event_propagation, { passive });

    				var n = document_listeners.get(event_name);

    				if (n === undefined) {
    					// The document listener ensures we catch events that originate from elements that were
    					// manually moved outside of the container (e.g. via manual portals).
    					document.addEventListener(event_name, handle_event_propagation, { passive });
    					document_listeners.set(event_name, 1);
    				} else {
    					document_listeners.set(event_name, n + 1);
    				}
    			}
    		};

    		event_handle(array_from(all_registered_events));
    		root_event_handles.add(event_handle);

    		/** @type {Exports} */
    		// @ts-expect-error will be defined because the render effect runs synchronously
    		var component = undefined;

    		var unmount = component_root(() => {
    			var anchor_node = anchor ?? target.appendChild(create_text());

    			branch(() => {
    				if (context) {
    					push({});
    					var ctx = /** @type {ComponentContext} */ (component_context);
    					ctx.c = context;
    				}

    				if (events) {
    					// We can't spread the object or else we'd lose the state proxy stuff, if it is one
    					/** @type {any} */ (props).$$events = events;
    				}

    				if (hydrating) {
    					assign_nodes(/** @type {TemplateNode} */ (anchor_node), null);
    				}
    				// @ts-expect-error the public typings are not what the actual function looks like
    				component = Component(anchor_node, props) || {};

    				if (hydrating) {
    					/** @type {Effect} */ (active_effect).nodes_end = hydrate_node;
    				}

    				if (context) {
    					pop();
    				}
    			});

    			return () => {
    				for (var event_name of registered_events) {
    					target.removeEventListener(event_name, handle_event_propagation);

    					var n = /** @type {number} */ (document_listeners.get(event_name));

    					if (--n === 0) {
    						document.removeEventListener(event_name, handle_event_propagation);
    						document_listeners.delete(event_name);
    					} else {
    						document_listeners.set(event_name, n);
    					}
    				}

    				root_event_handles.delete(event_handle);

    				if (anchor_node !== anchor) {
    					anchor_node.parentNode?.removeChild(anchor_node);
    				}
    			};
    		});

    		mounted_components.set(component, unmount);
    		return component;
    	}

    	/**
    	 * References of the components that were mounted or hydrated.
    	 * Uses a `WeakMap` to avoid memory leaks.
    	 */
    	let mounted_components = new WeakMap();

    	/**
    	 * Unmounts a component that was previously mounted using `mount` or `hydrate`.
    	 *
    	 * Since 5.13.0, if `options.outro` is `true`, [transitions](https://svelte.dev/docs/svelte/transition) will play before the component is removed from the DOM.
    	 *
    	 * Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
    	 *
    	 * ```js
    	 * import { mount, unmount } from 'svelte';
    	 * import App from './App.svelte';
    	 *
    	 * const app = mount(App, { target: document.body });
    	 *
    	 * // later...
    	 * unmount(app, { outro: true });
    	 * ```
    	 * @param {Record<string, any>} component
    	 * @param {{ outro?: boolean }} [options]
    	 * @returns {Promise<void>}
    	 */
    	function unmount(component, options) {
    		const fn = mounted_components.get(component);

    		if (fn) {
    			mounted_components.delete(component);
    			return fn(options);
    		}

    		return Promise.resolve();
    	}

    	/** @import { Effect, TemplateNode } from '#client' */

    	/**
    	 * @param {TemplateNode} node
    	 * @param {(branch: (fn: (anchor: Node) => void, flag?: boolean) => void) => void} fn
    	 * @param {boolean} [elseif] True if this is an `{:else if ...}` block rather than an `{#if ...}`, as that affects which transitions are considered 'local'
    	 * @returns {void}
    	 */
    	function if_block(node, fn, elseif = false) {
    		if (hydrating) {
    			hydrate_next();
    		}

    		var anchor = node;

    		/** @type {Effect | null} */
    		var consequent_effect = null;

    		/** @type {Effect | null} */
    		var alternate_effect = null;

    		/** @type {UNINITIALIZED | boolean | null} */
    		var condition = UNINITIALIZED;

    		var flags = elseif ? EFFECT_TRANSPARENT : 0;

    		var has_branch = false;

    		const set_branch = (/** @type {(anchor: Node) => void} */ fn, flag = true) => {
    			has_branch = true;
    			update_branch(flag, fn);
    		};

    		const update_branch = (
    			/** @type {boolean | null} */ new_condition,
    			/** @type {null | ((anchor: Node) => void)} */ fn
    		) => {
    			if (condition === (condition = new_condition)) return;

    			/** Whether or not there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */
    			let mismatch = false;

    			if (hydrating) {
    				const is_else = /** @type {Comment} */ (anchor).data === HYDRATION_START_ELSE;

    				if (!!condition === is_else) {
    					// Hydration mismatch: remove everything inside the anchor and start fresh.
    					// This could happen with `{#if browser}...{/if}`, for example
    					anchor = remove_nodes();

    					set_hydrate_node(anchor);
    					set_hydrating(false);
    					mismatch = true;
    				}
    			}

    			if (condition) {
    				if (consequent_effect) {
    					resume_effect(consequent_effect);
    				} else if (fn) {
    					consequent_effect = branch(() => fn(anchor));
    				}

    				if (alternate_effect) {
    					pause_effect(alternate_effect, () => {
    						alternate_effect = null;
    					});
    				}
    			} else {
    				if (alternate_effect) {
    					resume_effect(alternate_effect);
    				} else if (fn) {
    					alternate_effect = branch(() => fn(anchor));
    				}

    				if (consequent_effect) {
    					pause_effect(consequent_effect, () => {
    						consequent_effect = null;
    					});
    				}
    			}

    			if (mismatch) {
    				// continue in hydration mode
    				set_hydrating(true);
    			}
    		};

    		block(() => {
    			has_branch = false;
    			fn(set_branch);
    			if (!has_branch) {
    				update_branch(null, null);
    			}
    		}, flags);

    		if (hydrating) {
    			anchor = hydrate_node;
    		}
    	}

    	/** @import { EachItem, EachState, Effect, MaybeSource, Source, TemplateNode, TransitionManager, Value } from '#client' */

    	/**
    	 * @param {any} _
    	 * @param {number} i
    	 */
    	function index(_, i) {
    		return i;
    	}

    	/**
    	 * Pause multiple effects simultaneously, and coordinate their
    	 * subsequent destruction. Used in each blocks
    	 * @param {EachState} state
    	 * @param {EachItem[]} items
    	 * @param {null | Node} controlled_anchor
    	 * @param {Map<any, EachItem>} items_map
    	 */
    	function pause_effects(state, items, controlled_anchor, items_map) {
    		/** @type {TransitionManager[]} */
    		var transitions = [];
    		var length = items.length;

    		for (var i = 0; i < length; i++) {
    			pause_children(items[i].e, transitions, true);
    		}

    		var is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null;
    		// If we have a controlled anchor, it means that the each block is inside a single
    		// DOM element, so we can apply a fast-path for clearing the contents of the element.
    		if (is_controlled) {
    			var parent_node = /** @type {Element} */ (
    				/** @type {Element} */ (controlled_anchor).parentNode
    			);
    			clear_text_content(parent_node);
    			parent_node.append(/** @type {Element} */ (controlled_anchor));
    			items_map.clear();
    			link(state, items[0].prev, items[length - 1].next);
    		}

    		run_out_transitions(transitions, () => {
    			for (var i = 0; i < length; i++) {
    				var item = items[i];
    				if (!is_controlled) {
    					items_map.delete(item.k);
    					link(state, item.prev, item.next);
    				}
    				destroy_effect(item.e, !is_controlled);
    			}
    		});
    	}

    	/**
    	 * @template V
    	 * @param {Element | Comment} node The next sibling node, or the parent node if this is a 'controlled' block
    	 * @param {number} flags
    	 * @param {() => V[]} get_collection
    	 * @param {(value: V, index: number) => any} get_key
    	 * @param {(anchor: Node, item: MaybeSource<V>, index: MaybeSource<number>) => void} render_fn
    	 * @param {null | ((anchor: Node) => void)} fallback_fn
    	 * @returns {void}
    	 */
    	function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {
    		var anchor = node;

    		/** @type {EachState} */
    		var state = { flags, items: new Map(), first: null };

    		{
    			var parent_node = /** @type {Element} */ (node);

    			anchor = hydrating
    				? set_hydrate_node(/** @type {Comment | Text} */ (get_first_child(parent_node)))
    				: parent_node.appendChild(create_text());
    		}

    		if (hydrating) {
    			hydrate_next();
    		}

    		/** @type {Effect | null} */
    		var fallback = null;

    		var was_empty = false;

    		block(() => {
    			var collection = get_collection();

    			var array = is_array(collection)
    				? collection
    				: collection == null
    					? []
    					: array_from(collection);

    			var length = array.length;

    			if (was_empty && length === 0) {
    				// ignore updates if the array is empty,
    				// and it already was empty on previous run
    				return;
    			}
    			was_empty = length === 0;

    			/** `true` if there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */
    			let mismatch = false;

    			if (hydrating) {
    				var is_else = /** @type {Comment} */ (anchor).data === HYDRATION_START_ELSE;

    				if (is_else !== (length === 0)) {
    					// hydration mismatch — remove the server-rendered DOM and start over
    					anchor = remove_nodes();

    					set_hydrate_node(anchor);
    					set_hydrating(false);
    					mismatch = true;
    				}
    			}

    			// this is separate to the previous block because `hydrating` might change
    			if (hydrating) {
    				/** @type {EachItem | null} */
    				var prev = null;

    				/** @type {EachItem} */
    				var item;

    				for (var i = 0; i < length; i++) {
    					if (
    						hydrate_node.nodeType === 8 &&
    						/** @type {Comment} */ (hydrate_node).data === HYDRATION_END
    					) {
    						// The server rendered fewer items than expected,
    						// so break out and continue appending non-hydrated items
    						anchor = /** @type {Comment} */ (hydrate_node);
    						mismatch = true;
    						set_hydrating(false);
    						break;
    					}

    					var value = array[i];
    					var key = get_key(value, i);
    					item = create_item(
    						hydrate_node,
    						state,
    						prev,
    						null,
    						value,
    						key,
    						i,
    						render_fn,
    						flags);
    					state.items.set(key, item);

    					prev = item;
    				}

    				// remove excess nodes
    				if (length > 0) {
    					set_hydrate_node(remove_nodes());
    				}
    			}

    			if (!hydrating) {
    				var effect = /** @type {Effect} */ (active_reaction);
    				reconcile(
    					array,
    					state,
    					anchor,
    					render_fn,
    					flags,
    					(effect.f & INERT) !== 0,
    					get_key);
    			}

    			if (fallback_fn !== null) {
    				if (length === 0) {
    					if (fallback) {
    						resume_effect(fallback);
    					} else {
    						fallback = branch(() => fallback_fn(anchor));
    					}
    				} else if (fallback !== null) {
    					pause_effect(fallback, () => {
    						fallback = null;
    					});
    				}
    			}

    			if (mismatch) {
    				// continue in hydration mode
    				set_hydrating(true);
    			}

    			// When we mount the each block for the first time, the collection won't be
    			// connected to this effect as the effect hasn't finished running yet and its deps
    			// won't be assigned. However, it's possible that when reconciling the each block
    			// that a mutation occurred and it's made the collection MAYBE_DIRTY, so reading the
    			// collection again can provide consistency to the reactive graph again as the deriveds
    			// will now be `CLEAN`.
    			get_collection();
    		});

    		if (hydrating) {
    			anchor = hydrate_node;
    		}
    	}

    	/**
    	 * Add, remove, or reorder items output by an each block as its input changes
    	 * @template V
    	 * @param {Array<V>} array
    	 * @param {EachState} state
    	 * @param {Element | Comment | Text} anchor
    	 * @param {(anchor: Node, item: MaybeSource<V>, index: number | Source<number>) => void} render_fn
    	 * @param {number} flags
    	 * @param {boolean} is_inert
    	 * @param {(value: V, index: number) => any} get_key
    	 * @param {() => V[]} get_collection
    	 * @returns {void}
    	 */
    	function reconcile(array, state, anchor, render_fn, flags, is_inert, get_key, get_collection) {

    		var length = array.length;
    		var items = state.items;
    		var first = state.first;
    		var current = first;

    		/** @type {undefined | Set<EachItem>} */
    		var seen;

    		/** @type {EachItem | null} */
    		var prev = null;

    		/** @type {EachItem[]} */
    		var matched = [];

    		/** @type {EachItem[]} */
    		var stashed = [];

    		/** @type {V} */
    		var value;

    		/** @type {any} */
    		var key;

    		/** @type {EachItem | undefined} */
    		var item;

    		/** @type {number} */
    		var i;

    		for (i = 0; i < length; i += 1) {
    			value = array[i];
    			key = get_key(value, i);
    			item = items.get(key);

    			if (item === undefined) {
    				var child_anchor = current ? /** @type {TemplateNode} */ (current.e.nodes_start) : anchor;

    				prev = create_item(
    					child_anchor,
    					state,
    					prev,
    					prev === null ? state.first : prev.next,
    					value,
    					key,
    					i,
    					render_fn,
    					flags);

    				items.set(key, prev);

    				matched = [];
    				stashed = [];

    				current = prev.next;
    				continue;
    			}

    			{
    				update_item(item, value, i);
    			}

    			if ((item.e.f & INERT) !== 0) {
    				resume_effect(item.e);
    			}

    			if (item !== current) {
    				if (seen !== undefined && seen.has(item)) {
    					if (matched.length < stashed.length) {
    						// more efficient to move later items to the front
    						var start = stashed[0];
    						var j;

    						prev = start.prev;

    						var a = matched[0];
    						var b = matched[matched.length - 1];

    						for (j = 0; j < matched.length; j += 1) {
    							move(matched[j], start, anchor);
    						}

    						for (j = 0; j < stashed.length; j += 1) {
    							seen.delete(stashed[j]);
    						}

    						link(state, a.prev, b.next);
    						link(state, prev, a);
    						link(state, b, start);

    						current = start;
    						prev = b;
    						i -= 1;

    						matched = [];
    						stashed = [];
    					} else {
    						// more efficient to move earlier items to the back
    						seen.delete(item);
    						move(item, current, anchor);

    						link(state, item.prev, item.next);
    						link(state, item, prev === null ? state.first : prev.next);
    						link(state, prev, item);

    						prev = item;
    					}

    					continue;
    				}

    				matched = [];
    				stashed = [];

    				while (current !== null && current.k !== key) {
    					// If the each block isn't inert and an item has an effect that is already inert,
    					// skip over adding it to our seen Set as the item is already being handled
    					if (is_inert || (current.e.f & INERT) === 0) {
    						(seen ??= new Set()).add(current);
    					}
    					stashed.push(current);
    					current = current.next;
    				}

    				if (current === null) {
    					continue;
    				}

    				item = current;
    			}

    			matched.push(item);
    			prev = item;
    			current = item.next;
    		}

    		if (current !== null || seen !== undefined) {
    			var to_destroy = seen === undefined ? [] : array_from(seen);

    			while (current !== null) {
    				// If the each block isn't inert, then inert effects are currently outroing and will be removed once the transition is finished
    				if (is_inert || (current.e.f & INERT) === 0) {
    					to_destroy.push(current);
    				}
    				current = current.next;
    			}

    			var destroy_length = to_destroy.length;

    			if (destroy_length > 0) {
    				var controlled_anchor = length === 0 ? anchor : null;

    				pause_effects(state, to_destroy, controlled_anchor, items);
    			}
    		}

    		/** @type {Effect} */ (active_effect).first = state.first && state.first.e;
    		/** @type {Effect} */ (active_effect).last = prev && prev.e;
    	}

    	/**
    	 * @param {EachItem} item
    	 * @param {any} value
    	 * @param {number} index
    	 * @param {number} type
    	 * @returns {void}
    	 */
    	function update_item(item, value, index, type) {
    		{
    			internal_set(item.v, value);
    		}

    		{
    			item.i = index;
    		}
    	}

    	/**
    	 * @template V
    	 * @param {Node} anchor
    	 * @param {EachState} state
    	 * @param {EachItem | null} prev
    	 * @param {EachItem | null} next
    	 * @param {V} value
    	 * @param {unknown} key
    	 * @param {number} index
    	 * @param {(anchor: Node, item: V | Source<V>, index: number | Value<number>) => void} render_fn
    	 * @param {number} flags
    	 * @param {() => V[]} get_collection
    	 * @returns {EachItem}
    	 */
    	function create_item(
    		anchor,
    		state,
    		prev,
    		next,
    		value,
    		key,
    		index,
    		render_fn,
    		flags,
    		get_collection
    	) {
    		var reactive = (flags & EACH_ITEM_REACTIVE) !== 0;
    		var mutable = (flags & EACH_ITEM_IMMUTABLE) === 0;

    		var v = reactive ? (mutable ? mutable_source(value) : source(value)) : value;
    		var i = (flags & EACH_INDEX_REACTIVE) === 0 ? index : source(index);

    		/** @type {EachItem} */
    		var item = {
    			i,
    			v,
    			k: key,
    			a: null,
    			// @ts-expect-error
    			e: null,
    			prev,
    			next
    		};

    		try {
    			item.e = branch(() => render_fn(anchor, v, i), hydrating);

    			item.e.prev = prev && prev.e;
    			item.e.next = next && next.e;

    			if (prev === null) {
    				state.first = item;
    			} else {
    				prev.next = item;
    				prev.e.next = item.e;
    			}

    			if (next !== null) {
    				next.prev = item;
    				next.e.prev = item.e;
    			}

    			return item;
    		} finally {
    		}
    	}

    	/**
    	 * @param {EachItem} item
    	 * @param {EachItem | null} next
    	 * @param {Text | Element | Comment} anchor
    	 */
    	function move(item, next, anchor) {
    		var end = item.next ? /** @type {TemplateNode} */ (item.next.e.nodes_start) : anchor;

    		var dest = next ? /** @type {TemplateNode} */ (next.e.nodes_start) : anchor;
    		var node = /** @type {TemplateNode} */ (item.e.nodes_start);

    		while (node !== end) {
    			var next_node = /** @type {TemplateNode} */ (get_next_sibling(node));
    			dest.before(node);
    			node = next_node;
    		}
    	}

    	/**
    	 * @param {EachState} state
    	 * @param {EachItem | null} prev
    	 * @param {EachItem | null} next
    	 */
    	function link(state, prev, next) {
    		if (prev === null) {
    			state.first = next;
    		} else {
    			prev.next = next;
    			prev.e.next = next && next.e;
    		}

    		if (next !== null) {
    			next.prev = prev;
    			next.e.prev = prev && prev.e;
    		}
    	}

    	/**
    	 * @param {Node} anchor
    	 * @param {{ hash: string, code: string }} css
    	 */
    	function append_styles(anchor, css) {
    		// Use `queue_micro_task` to ensure `anchor` is in the DOM, otherwise getRootNode() will yield wrong results
    		queue_micro_task(() => {
    			var root = anchor.getRootNode();

    			var target = /** @type {ShadowRoot} */ (root).host
    				? /** @type {ShadowRoot} */ (root)
    				: /** @type {Document} */ (root).head ?? /** @type {Document} */ (root.ownerDocument).head;

    			// Always querying the DOM is roughly the same perf as additionally checking for presence in a map first assuming
    			// that you'll get cache hits half of the time, so we just always query the dom for simplicity and code savings.
    			if (!target.querySelector('#' + css.hash)) {
    				const style = document.createElement('style');
    				style.id = css.hash;
    				style.textContent = css.code;

    				target.appendChild(style);
    			}
    		});
    	}

    	/** @import { ComponentConstructorOptions, ComponentType, SvelteComponent, Component } from 'svelte' */

    	/**
    	 * Takes the same options as a Svelte 4 component and the component function and returns a Svelte 4 compatible component.
    	 *
    	 * @deprecated Use this only as a temporary solution to migrate your imperative component code to Svelte 5.
    	 *
    	 * @template {Record<string, any>} Props
    	 * @template {Record<string, any>} Exports
    	 * @template {Record<string, any>} Events
    	 * @template {Record<string, any>} Slots
    	 *
    	 * @param {ComponentConstructorOptions<Props> & {
    	 * 	component: ComponentType<SvelteComponent<Props, Events, Slots>> | Component<Props>;
    	 * }} options
    	 * @returns {SvelteComponent<Props, Events, Slots> & Exports}
    	 */
    	function createClassComponent(options) {
    		// @ts-expect-error $$prop_def etc are not actually defined
    		return new Svelte4Component(options);
    	}

    	/**
    	 * Support using the component as both a class and function during the transition period
    	 * @typedef  {{new (o: ComponentConstructorOptions): SvelteComponent;(...args: Parameters<Component<Record<string, any>>>): ReturnType<Component<Record<string, any>, Record<string, any>>>;}} LegacyComponentType
    	 */

    	class Svelte4Component {
    		/** @type {any} */
    		#events;

    		/** @type {Record<string, any>} */
    		#instance;

    		/**
    		 * @param {ComponentConstructorOptions & {
    		 *  component: any;
    		 * }} options
    		 */
    		constructor(options) {
    			var sources = new Map();

    			/**
    			 * @param {string | symbol} key
    			 * @param {unknown} value
    			 */
    			var add_source = (key, value) => {
    				var s = mutable_source(value);
    				sources.set(key, s);
    				return s;
    			};

    			// Replicate coarse-grained props through a proxy that has a version source for
    			// each property, which is incremented on updates to the property itself. Do not
    			// use our $state proxy because that one has fine-grained reactivity.
    			const props = new Proxy(
    				{ ...(options.props || {}), $$events: {} },
    				{
    					get(target, prop) {
    						return get(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));
    					},
    					has(target, prop) {
    						// Necessary to not throw "invalid binding" validation errors on the component side
    						if (prop === LEGACY_PROPS) return true;

    						get(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));
    						return Reflect.has(target, prop);
    					},
    					set(target, prop, value) {
    						set(sources.get(prop) ?? add_source(prop, value), value);
    						return Reflect.set(target, prop, value);
    					}
    				}
    			);

    			this.#instance = (options.hydrate ? hydrate : mount)(options.component, {
    				target: options.target,
    				anchor: options.anchor,
    				props,
    				context: options.context,
    				intro: options.intro ?? false,
    				recover: options.recover
    			});

    			// We don't flush_sync for custom element wrappers or if the user doesn't want it
    			if (!options?.props?.$$host || options.sync === false) {
    				flush_sync();
    			}

    			this.#events = props.$$events;

    			for (const key of Object.keys(this.#instance)) {
    				if (key === '$set' || key === '$destroy' || key === '$on') continue;
    				define_property(this, key, {
    					get() {
    						return this.#instance[key];
    					},
    					/** @param {any} value */
    					set(value) {
    						this.#instance[key] = value;
    					},
    					enumerable: true
    				});
    			}

    			this.#instance.$set = /** @param {Record<string, any>} next */ (next) => {
    				Object.assign(props, next);
    			};

    			this.#instance.$destroy = () => {
    				unmount(this.#instance);
    			};
    		}

    		/** @param {Record<string, any>} props */
    		$set(props) {
    			this.#instance.$set(props);
    		}

    		/**
    		 * @param {string} event
    		 * @param {(...args: any[]) => any} callback
    		 * @returns {any}
    		 */
    		$on(event, callback) {
    			this.#events[event] = this.#events[event] || [];

    			/** @param {any[]} args */
    			const cb = (...args) => callback.call(this, ...args);
    			this.#events[event].push(cb);
    			return () => {
    				this.#events[event] = this.#events[event].filter(/** @param {any} fn */ (fn) => fn !== cb);
    			};
    		}

    		$destroy() {
    			this.#instance.$destroy();
    		}
    	}

    	/**
    	 * @typedef {Object} CustomElementPropDefinition
    	 * @property {string} [attribute]
    	 * @property {boolean} [reflect]
    	 * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]
    	 */

    	/** @type {any} */
    	let SvelteElement;

    	if (typeof HTMLElement === 'function') {
    		SvelteElement = class extends HTMLElement {
    			/** The Svelte component constructor */
    			$$ctor;
    			/** Slots */
    			$$s;
    			/** @type {any} The Svelte component instance */
    			$$c;
    			/** Whether or not the custom element is connected */
    			$$cn = false;
    			/** @type {Record<string, any>} Component props data */
    			$$d = {};
    			/** `true` if currently in the process of reflecting component props back to attributes */
    			$$r = false;
    			/** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
    			$$p_d = {};
    			/** @type {Record<string, EventListenerOrEventListenerObject[]>} Event listeners */
    			$$l = {};
    			/** @type {Map<EventListenerOrEventListenerObject, Function>} Event listener unsubscribe functions */
    			$$l_u = new Map();
    			/** @type {any} The managed render effect for reflecting attributes */
    			$$me;

    			/**
    			 * @param {*} $$componentCtor
    			 * @param {*} $$slots
    			 * @param {*} use_shadow_dom
    			 */
    			constructor($$componentCtor, $$slots, use_shadow_dom) {
    				super();
    				this.$$ctor = $$componentCtor;
    				this.$$s = $$slots;
    				if (use_shadow_dom) {
    					this.attachShadow({ mode: 'open' });
    				}
    			}

    			/**
    			 * @param {string} type
    			 * @param {EventListenerOrEventListenerObject} listener
    			 * @param {boolean | AddEventListenerOptions} [options]
    			 */
    			addEventListener(type, listener, options) {
    				// We can't determine upfront if the event is a custom event or not, so we have to
    				// listen to both. If someone uses a custom event with the same name as a regular
    				// browser event, this fires twice - we can't avoid that.
    				this.$$l[type] = this.$$l[type] || [];
    				this.$$l[type].push(listener);
    				if (this.$$c) {
    					const unsub = this.$$c.$on(type, listener);
    					this.$$l_u.set(listener, unsub);
    				}
    				super.addEventListener(type, listener, options);
    			}

    			/**
    			 * @param {string} type
    			 * @param {EventListenerOrEventListenerObject} listener
    			 * @param {boolean | AddEventListenerOptions} [options]
    			 */
    			removeEventListener(type, listener, options) {
    				super.removeEventListener(type, listener, options);
    				if (this.$$c) {
    					const unsub = this.$$l_u.get(listener);
    					if (unsub) {
    						unsub();
    						this.$$l_u.delete(listener);
    					}
    				}
    			}

    			async connectedCallback() {
    				this.$$cn = true;
    				if (!this.$$c) {
    					// We wait one tick to let possible child slot elements be created/mounted
    					await Promise.resolve();
    					if (!this.$$cn || this.$$c) {
    						return;
    					}
    					/** @param {string} name */
    					function create_slot(name) {
    						/**
    						 * @param {Element} anchor
    						 */
    						return (anchor) => {
    							const slot = document.createElement('slot');
    							if (name !== 'default') slot.name = name;

    							append(anchor, slot);
    						};
    					}
    					/** @type {Record<string, any>} */
    					const $$slots = {};
    					const existing_slots = get_custom_elements_slots(this);
    					for (const name of this.$$s) {
    						if (name in existing_slots) {
    							if (name === 'default' && !this.$$d.children) {
    								this.$$d.children = create_slot(name);
    								$$slots.default = true;
    							} else {
    								$$slots[name] = create_slot(name);
    							}
    						}
    					}
    					for (const attribute of this.attributes) {
    						// this.$$data takes precedence over this.attributes
    						const name = this.$$g_p(attribute.name);
    						if (!(name in this.$$d)) {
    							this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, 'toProp');
    						}
    					}
    					// Port over props that were set programmatically before ce was initialized
    					for (const key in this.$$p_d) {
    						// @ts-expect-error
    						if (!(key in this.$$d) && this[key] !== undefined) {
    							// @ts-expect-error
    							this.$$d[key] = this[key]; // don't transform, these were set through JavaScript
    							// @ts-expect-error
    							delete this[key]; // remove the property that shadows the getter/setter
    						}
    					}
    					this.$$c = createClassComponent({
    						component: this.$$ctor,
    						target: this.shadowRoot || this,
    						props: {
    							...this.$$d,
    							$$slots,
    							$$host: this
    						}
    					});

    					// Reflect component props as attributes
    					this.$$me = effect_root(() => {
    						render_effect(() => {
    							this.$$r = true;
    							for (const key of object_keys(this.$$c)) {
    								if (!this.$$p_d[key]?.reflect) continue;
    								this.$$d[key] = this.$$c[key];
    								const attribute_value = get_custom_element_value(
    									key,
    									this.$$d[key],
    									this.$$p_d,
    									'toAttribute'
    								);
    								if (attribute_value == null) {
    									this.removeAttribute(this.$$p_d[key].attribute || key);
    								} else {
    									this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
    								}
    							}
    							this.$$r = false;
    						});
    					});

    					for (const type in this.$$l) {
    						for (const listener of this.$$l[type]) {
    							const unsub = this.$$c.$on(type, listener);
    							this.$$l_u.set(listener, unsub);
    						}
    					}
    					this.$$l = {};
    				}
    			}

    			// We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    			// and setting attributes through setAttribute etc, this is helpful

    			/**
    			 * @param {string} attr
    			 * @param {string} _oldValue
    			 * @param {string} newValue
    			 */
    			attributeChangedCallback(attr, _oldValue, newValue) {
    				if (this.$$r) return;
    				attr = this.$$g_p(attr);
    				this.$$d[attr] = get_custom_element_value(attr, newValue, this.$$p_d, 'toProp');
    				this.$$c?.$set({ [attr]: this.$$d[attr] });
    			}

    			disconnectedCallback() {
    				this.$$cn = false;
    				// In a microtask, because this could be a move within the DOM
    				Promise.resolve().then(() => {
    					if (!this.$$cn && this.$$c) {
    						this.$$c.$destroy();
    						this.$$me();
    						this.$$c = undefined;
    					}
    				});
    			}

    			/**
    			 * @param {string} attribute_name
    			 */
    			$$g_p(attribute_name) {
    				return (
    					object_keys(this.$$p_d).find(
    						(key) =>
    							this.$$p_d[key].attribute === attribute_name ||
    							(!this.$$p_d[key].attribute && key.toLowerCase() === attribute_name)
    					) || attribute_name
    				);
    			}
    		};
    	}

    	/**
    	 * @param {string} prop
    	 * @param {any} value
    	 * @param {Record<string, CustomElementPropDefinition>} props_definition
    	 * @param {'toAttribute' | 'toProp'} [transform]
    	 */
    	function get_custom_element_value(prop, value, props_definition, transform) {
    		const type = props_definition[prop]?.type;
    		value = type === 'Boolean' && typeof value !== 'boolean' ? value != null : value;
    		if (!transform || !props_definition[prop]) {
    			return value;
    		} else if (transform === 'toAttribute') {
    			switch (type) {
    				case 'Object':
    				case 'Array':
    					return value == null ? null : JSON.stringify(value);
    				case 'Boolean':
    					return value ? '' : null;
    				case 'Number':
    					return value == null ? null : value;
    				default:
    					return value;
    			}
    		} else {
    			switch (type) {
    				case 'Object':
    				case 'Array':
    					return value && JSON.parse(value);
    				case 'Boolean':
    					return value; // conversion already handled above
    				case 'Number':
    					return value != null ? +value : value;
    				default:
    					return value;
    			}
    		}
    	}

    	/**
    	 * @param {HTMLElement} element
    	 */
    	function get_custom_elements_slots(element) {
    		/** @type {Record<string, true>} */
    		const result = {};
    		element.childNodes.forEach((node) => {
    			result[/** @type {Element} node */ (node).slot || 'default'] = true;
    		});
    		return result;
    	}

    	/**
    	 * @internal
    	 *
    	 * Turn a Svelte component into a custom element.
    	 * @param {any} Component  A Svelte component function
    	 * @param {Record<string, CustomElementPropDefinition>} props_definition  The props to observe
    	 * @param {string[]} slots  The slots to create
    	 * @param {string[]} exports  Explicitly exported values, other than props
    	 * @param {boolean} use_shadow_dom  Whether to use shadow DOM
    	 * @param {(ce: new () => HTMLElement) => new () => HTMLElement} [extend]
    	 */
    	function create_custom_element(
    		Component,
    		props_definition,
    		slots,
    		exports,
    		use_shadow_dom,
    		extend
    	) {
    		let Class = class extends SvelteElement {
    			constructor() {
    				super(Component, slots, use_shadow_dom);
    				this.$$p_d = props_definition;
    			}
    			static get observedAttributes() {
    				return object_keys(props_definition).map((key) =>
    					(props_definition[key].attribute || key).toLowerCase()
    				);
    			}
    		};
    		object_keys(props_definition).forEach((prop) => {
    			define_property(Class.prototype, prop, {
    				get() {
    					return this.$$c && prop in this.$$c ? this.$$c[prop] : this.$$d[prop];
    				},
    				set(value) {
    					value = get_custom_element_value(prop, value, props_definition);
    					this.$$d[prop] = value;
    					var component = this.$$c;

    					if (component) {
    						// // If the instance has an accessor, use that instead
    						var setter = get_descriptor(component, prop)?.get;

    						if (setter) {
    							component[prop] = value;
    						} else {
    							component.$set({ [prop]: value });
    						}
    					}
    				}
    			});
    		});
    		exports.forEach((property) => {
    			define_property(Class.prototype, property, {
    				get() {
    					return this.$$c?.[property];
    				}
    			});
    		});
    		Component.element = /** @type {any} */ Class;
    		return Class;
    	}

    	let patterns = [

    	  // the first two patterns must be kept at the top of the list so they can easily be handled as a special case
    	  'cet(ear)?yl alcohol',
    	  'ceteareth[\- ]20',

    	  '1-acetoxyhexadecane',
    	  '1-hexadecanol( acetate)?',
    	  'acetic acid hexadecyl ester',
    	  'acetylated lanolin( alcohol)?',
    	  'acetylated wool (fat|wax)',
    	  'adansonia digitata l.',
    	  'agar',
    	  'ahnfeltiopsis concinna extract',
    	  'alaria esculenta extract',
    	  'alga bladderwrack',
    	  'algae( extract)?',
    	  'algin(ate)?',
    	  'alginic acid',
    	  'aphanothece sacrum polysaccharide',
    	  'arthrospira plantensis',
    	  'ascophyllum nodosum extract',
    	  'asparagopsis armata extract',
    	  'baobab',
    	  'beeswax',
    	  'bismuth',
    	  'bryopsis africana',
    	  'butyl (octadecanoate|stearate|stearic acid)',
    	  '(butyrospermum parkii|shea|butyrospermum|parkii)( butter)?',
    	  'cacao seed butter',
    	  'capea biruncinata var. (denuda|elongata) sonder',
    	  'carastay c',
    	  '(carrageenan|chondrus( crispus)?|irish)( (moss|gum))?( extract)?',
    	  'caulerpa (lentillifera|filiformis)( extract)?',
    	  'cera (alba|bianca|flava|olea)',
    	  'cetearyl alcohol \\+ ceteareth 20',
    	  'cetyl (acetate|alcohol)',
    	  'chaetomorpha linum \\(aerea\\) cladophora radiosa',
    	  'chlamydomonas reinhardtii extract',
    	  'chlorella',
    	  'chlorophyceae',
    	  'cladophora cf. subsimplex',
    	  'cladosiphon okamuranus extract',
    	  'coal tar',
    	  'cocoa butter',
    	  'coco-capr(yl)?ate',
    	  '(cocos nucifera|coconut) ( seed)?(oil|alkanes|butter|extract)',
    	  'coenochloris signiensis extract',
    	  'colloidal sulfur',
    	  'corallina officinalis extract',
    	  'corn( oil)?',
    	  'creosote',
    	  'cystoseira tamariscifolia extract',
    	  'd ?&? ?c red #?(17|21|3|30|36)',
    	  'decyl ?oleate',
    	  'dicotyledons succinate',
    	  'dictyopteris membranacea',
    	  'dictyopteris polypodioides',
    	  'di(ethylhexyl|octyl) sodium sulfosuccinate',
    	  'diisooctyl succinate',
    	  'dilsea carnosa extract',
    	  'dioctyl succinate',
    	  'disodium laureth sulfosuccinate',
    	  'disodium monooleamido',
    	  'disodium monooleamido( peg[\- ]2 sulfosuccinate)?',
    	  'disodium oleamido peg-2 sulfosuccinate',
    	  'dodec((an)?oic|ylic) acid',
    	  'dunaliella salina extract',
    	  'duodecylic acid',
    	  'durvillaea antarctica extract',
    	  'ecklonia (cava|radiata)( extract)?',
    	  'enteromorpha compressa extract',
    	  'ethoxylated lanolin',
    	  'ethylhexyl (palmitate|stearate)',
    	  'eucheuma spinosum extract',
    	  'fucoxanthin',
    	  'fucus (serratus|vesiculosus)',
    	  'gamtae extract',
    	  'gelidiella acerosa extract',
    	  'gelidium amansii extract',
    	  'gigartina stellata extract',
    	  'glyceryl[\- ]3 diisostearate',
    	  'glyceryl monostearate',
    	  'glyceryl stearate se',
    	  'glycine max',
    	  '(glycine soja|soybean) oil',
    	  '(gossypium herbaceum|cotton|awws|sclerocarya birrea) seed oil',
    	  'gracilariopsis chorda extract',
    	  'haematococcus pluvialis( extract)?',
    	  'haslea ostrearia extract',
    	  'hexadecanol acetate',
    	  'hexadecyl acetate',
    	  'hexadecyl alcohol',
    	  'himanthalia elongata extract',
    	  'hizikia fusiforme extract',
    	  'hydrogenated (vegetable|sunflower|castor|jojoba) (seed )?oil',
    	  'hydrolyzed rhodophycea extract',
    	  'hydrous magnesium silicate',
    	  'hypneaceae extract',
    	  'hypnea musciformis extract',
    	  'isocetyl (alcohol|stearate)',
    	  'isodecyl oleate',
    	  'isohexadecanol',
    	  'isohexadecyl (stearate|alcohol)',
    	  'isooctadecyl isooctadecanoate',
    	  'isopalmit(ic|yl) alcohol',
    	  'isopropyl (iso(stear|decano)|linol|myrist|palmit)ate',
    	  'isostearyl ((isostear|neopentano)ate)',
    	  'jania rubens extract',
    	  'jojoba wax',
    	  'kappaphycus alvarezii extract',
    	  'karite',
    	  'kelp',
    	  'kousou ekisu',
    	  'laminaria (digitata|saccharin[ae])( extract)?',
    	  'lanolin( alcohol)? acetate',
    	  'lanolin polyoxyethylene ether',
    	  'laureth[\- ](23|4)',
    	  'lauric acid',
    	  'laurostearic acid',
    	  'lcd',
    	  'linolate',
    	  'liquor carbonis detergens',
    	  'liquor picis carbonis',
    	  'lithothamnium calcareum powder',
    	  'lpc',
    	  'macroalgae',
    	  'macrocystis pyrifera extract',
    	  'mangifera indica seed butter',
    	  'mango butter',
    	  'marula( oil)?',
    	  'methylsilanol mannuronate',
    	  'mink oil',
    	  'moss',
    	  'myristate',
    	  'myristic acid',
    	  'myristyl( (lac|myris|propion)tate)?',
    	  'n-hexadecyl (alcohol|ethenoate)',
    	  'octadecanoic acid',
    	  'octadecyl heptanoate',
    	  'octyl (palmit|stear)ate',
    	  'oleth[\- ]3( phosphate)?',
    	  'oleyl alcohol',
    	  'palmaria palmata extract',
    	  'palmityl (acetate|alcohol)',
    	  'peg[\- ]16 lanolin',
    	  'peg[\- ]200 dilaurate',
    	  'peg[\- ]2 sulfosuccinate',
    	  'peg[\- ]75',
    	  'peg[\- ]8 stearate',
    	  'pelvetia canaliculata extract',
    	  'pes',
    	  'pg monostearate',
    	  'pgms',
    	  'phaeodactylum tricornutum extract',
    	  'phaeophyceae',
    	  'pix carbonis',
    	  'plankton',
    	  'polyethylene glycol (200|dodecyl ether|jojoba acid|lauryl ether|monododecyl ether|stearate)',
    	  'polyglyceryl[\- ]3[\- ]diisostearate',
    	  'polyoxyethylene lauryl ether',
    	  'polysiphonia elongata extract',
    	  'porphyra umbilicalis',
    	  'porphyridium( (cruentum extract|polysaccharide))?',
    	  'potassium (chloride|salt)',
    	  'ppg[\- ]2 myristyl( (ether )?propionate)',
    	  'propanoic acid',
    	  'propylene glycol monostearate',
    	  'pyrene coal tar pitch',
    	  '(red )?algae( extract)?',
    	  'rhodophyceae extract',
    	  'rhodophyta',
    	  'sargassum (filipendula|fusiforme) extract',
    	  'sclerocarya birrea',
    	  'sea fern',
    	  'seaweed',
    	  'sesame',
    	  'sesamum indicum',
    	  'shark liver oil',
    	  '(shark )?squal[ae]ne',
    	  'sheep alcohol',
    	  'simmondsia chinensis seed wax',
    	  'sles',
    	  'slo',
    	  'sls',
    	  'sodium alginate',
    	  'sodium alkylethersulfate',
    	  'sodium docusate',
    	  'sodium dodecyl sulphate',
    	  'sodium lauryl ether sulfate',
    	  'sodium laur(yl|eth) sulfate',
    	  'soja',
    	  'solulan 16',
    	  'sorbitan (mono)?oleate',
    	  'soy(bean)?( oil)?',
    	  'sphacelaria',
    	  'spirulina',
    	  'starch',
    	  'steareth[\- ]10',
    	  'stearic acid tea',
    	  'stearyl heptanoate',
    	  'sul(f|ph)ated (castor|jojoba) oil',
    	  'sulfosuccinate',
    	  'talc(um)?',
    	  'tea stearate',
    	  'tetradecanoic acid',
    	  'tetradecyl (lactate|myristate|propionate)',
    	  'theobroma( cocoa)?( seed)? (butter|oil)?',
    	  'triticum (aestivum|vulgare)',
    	  'turkey red oil',
    	  'ulva (fasciata|lactuca|rhacodes)',
    	  'undaria pinnatifida',
    	  'vegetable gelatin',
    	  'vitellaria paradoxa',
    	  'vulvic acid',
    	  'wakame',
    	  'wheat( germ (oil|glyceride))?',
    	  'wool (alcohol|fat)',
    	  'xanthophyta',
    	  'xyl(ene|itol)',
    	  'zea mays',
    	];

    	// Replace each space with a wildcard pattern for non-word characters.
    	// Also insert the same wildcard at the start and end of each pattern.
    	var comedogen_regexps = patterns.map(pattern => new RegExp('^\\s*?' + pattern + '\\s*?$', 'i'));

    	function check(
    		event,
    		input_box_text,
    		comedogens,
    		find_comedogens
    	) {
    		set(input_box_text, proxy(event.target.value));

    		if (!get(input_box_text)) {
    			set(comedogens, proxy([]));
    		} else {
    			set(comedogens, proxy(find_comedogens(comedogen_regexps, get(input_box_text).split(','))));

    			// The first two comedogens are a special case because they must both be present to be an issue.
    			let [a, b] = [
    				get(comedogens).find((c) => comedogen_regexps[0].test(c)),
    				get(comedogens).find((c) => comedogen_regexps[1].test(c))
    			]; // the two comedogens from `comedogens` if found, otherwise `undefined` for those that are not found

    			if (a === undefined != (b === undefined)) {
    				// only one is present
    				set(comedogens, proxy(get(comedogens).filter((c) => c != a && c != b))); // remove either ingredient
    			} else if (a !== undefined && b !== undefined) {
    				// both are present
    				set(comedogens, proxy(get(comedogens).filter((c) => c != a && c != b))); // remove both ingredients
    				get(comedogens).push(`${a} + ${b}`); // replace with combined result to emphasize their relationship
    			}
    		}
    	}

    	var root_1 = template(`<p style="font-size: 1mm">...</p>`);
    	var root_3 = template(`<p>No pore-clogging ingredients found!</p>`);
    	var root_5 = template(`<li> </li>`);
    	var root_4 = template(`<p>The following ingredients can worsen acne:</p> <ul></ul>`, 1);
    	var root = template(`<div id="root" class="svelte-1ewsj88"><label for="textarea" class="svelte-1ewsj88">The ingredient list must be separated by commas.</label> <textarea id="textarea" placeholder="Paste ingredient list here." spellcheck="false" translate="no" class="svelte-1ewsj88"></textarea> <div id="results" class="svelte-1ewsj88"><!></div></div>`);

    	const $$css = {
    		hash: "svelte-1ewsj88",
    		code: "label.svelte-1ewsj88, textarea.svelte-1ewsj88 {letter-spacing:1px;}textarea.svelte-1ewsj88 {padding:10px;width:100%;line-height:1.5;border-radius:5px;border:1px solid #ccc;box-shadow:1px 1px 1px #999;box-sizing:border-box;}label.svelte-1ewsj88 {display:block;margin-bottom:10px;}div#root.svelte-1ewsj88 {min-width:5cm;max-width:40cm;background-color:#292c30;padding:2mm;color:white;font-family:sans-serif;}div#results.svelte-1ewsj88 {border:0.5mm, solid, #727a85;margin-top:2mm;padding:2mm;min-height:4cm;}"
    	};

    	function IngredientChecker($$anchor, $$props) {
    		push($$props, true);
    		append_styles($$anchor, $$css);

    		// split parenthesized items out of strings 
    		function extract_parenthesized(ingredient) {
    			let items = ingredient.match(/\(.*?\)/g);

    			let results = [
    				ingredient.replace(/\(.*?\)/g, '').replace(/ +/g, ' ')
    			];

    			if (items) {
    				results = results.concat(items.map((i) => i.replace(/[()]/g, '')));
    			}

    			return results;
    		}

    		function find_comedogens(forbidden_ingredients, ingredients) {
    			return ingredients.filter((i) => forbidden_ingredients.some((f) => extract_parenthesized(i.replace(/(\*|†|‡)*/g, '')).some((j) => f.test(j))));
    		}

    		let comedogens = state(proxy([]));
    		let input_box_text = state('');
    		var div = root();
    		var textarea = sibling(child(div), 2);

    		textarea.__input = [
    			check,
    			input_box_text,
    			comedogens,
    			find_comedogens
    		];

    		var div_1 = sibling(textarea, 2);
    		var node = child(div_1);

    		{
    			var consequent = ($$anchor) => {
    				var p = root_1();

    				append($$anchor, p);
    			};

    			var alternate_1 = ($$anchor) => {
    				var fragment = comment();
    				var node_1 = first_child(fragment);

    				{
    					var consequent_1 = ($$anchor) => {
    						var p_1 = root_3();

    						append($$anchor, p_1);
    					};

    					var alternate = ($$anchor) => {
    						var fragment_1 = root_4();
    						var ul = sibling(first_child(fragment_1), 2);

    						each(ul, 21, () => get(comedogens), index, ($$anchor, ingredient) => {
    							var li = root_5();
    							var text = child(li, true);

    							reset(li);
    							template_effect(() => set_text(text, get(ingredient)));
    							append($$anchor, li);
    						});

    						reset(ul);
    						append($$anchor, fragment_1);
    					};

    					if_block(
    						node_1,
    						($$render) => {
    							if (get(comedogens).length == 0) $$render(consequent_1); else $$render(alternate, false);
    						},
    						true
    					);
    				}

    				append($$anchor, fragment);
    			};

    			if_block(node, ($$render) => {
    				if (get(input_box_text) == '') $$render(consequent); else $$render(alternate_1, false);
    			});
    		}

    		reset(div_1);
    		reset(div);
    		append($$anchor, div);
    		pop();
    	}

    	delegate(["input"]);
    	customElements.define("ingredient-checker", create_custom_element(IngredientChecker, {}, [], [], true));

    	return IngredientChecker;

    })();
  </script>
  <body>
    <ingredient-checker />
  </body>
</html>
